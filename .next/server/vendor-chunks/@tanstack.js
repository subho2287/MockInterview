"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll),\n/* harmony export */   measureElement: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect),\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer),\n/* harmony export */   windowScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n\n\n\n\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n    const rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(()=>({}), {})[1];\n    const resolvedOptions = {\n        ...options,\n        onChange: (instance2, sync)=>{\n            var _a;\n            if (sync) {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n            } else {\n                rerender();\n            }\n            (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n        }\n    };\n    const [instance] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions));\n    instance.setOptions(resolvedOptions);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return instance._didMount();\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        return instance._willUpdate();\n    });\n    return instance;\n}\nfunction useVirtualizer(options) {\n    return useVirtualizerBase({\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll,\n        ...options\n    });\n}\nfunction useWindowVirtualizer(options) {\n    return useVirtualizerBase({\n        getScrollElement: ()=>typeof document !== \"undefined\" ? window : null,\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n        initialOffset: ()=>typeof document !== \"undefined\" ? window.scrollY : 0,\n        ...options\n    });\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNPO0FBQzhIO0FBQzdIO0FBQ3ZDLE1BQU1TLDRCQUE0QixPQUFPQyxhQUFhLGNBQWNWLGtEQUFxQixHQUFHQSw0Q0FBZTtBQUMzRyxTQUFTYSxtQkFBbUJDLE9BQU87SUFDakMsTUFBTUMsV0FBV2YsNkNBQWdCLENBQUMsSUFBTyxFQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNwRCxNQUFNaUIsa0JBQWtCO1FBQ3RCLEdBQUdILE9BQU87UUFDVkksVUFBVSxDQUFDQyxXQUFXQztZQUNwQixJQUFJQztZQUNKLElBQUlELE1BQU07Z0JBQ1JuQixvREFBU0EsQ0FBQ2M7WUFDWixPQUFPO2dCQUNMQTtZQUNGO1lBQ0NNLENBQUFBLEtBQUtQLFFBQVFJLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSUcsR0FBR0MsSUFBSSxDQUFDUixTQUFTSyxXQUFXQztRQUN6RTtJQUNGO0lBQ0EsTUFBTSxDQUFDRyxTQUFTLEdBQUd2QiwyQ0FBYyxDQUMvQixJQUFNLElBQUlRLCtEQUFXQSxDQUFDUztJQUV4Qk0sU0FBU0UsVUFBVSxDQUFDUjtJQUNwQmpCLDRDQUFlLENBQUM7UUFDZCxPQUFPdUIsU0FBU0csU0FBUztJQUMzQixHQUFHLEVBQUU7SUFDTGpCLDBCQUEwQjtRQUN4QixPQUFPYyxTQUFTSSxXQUFXO0lBQzdCO0lBQ0EsT0FBT0o7QUFDVDtBQUNBLFNBQVNLLGVBQWVkLE9BQU87SUFDN0IsT0FBT0QsbUJBQW1CO1FBQ3hCWCxrQkFBa0JBLHdFQUFBQTtRQUNsQkMsb0JBQW9CQSwwRUFBQUE7UUFDcEIwQixZQUFZekIsaUVBQWFBO1FBQ3pCLEdBQUdVLE9BQU87SUFDWjtBQUNGO0FBQ0EsU0FBU2dCLHFCQUFxQmhCLE9BQU87SUFDbkMsT0FBT0QsbUJBQW1CO1FBQ3hCa0Isa0JBQWtCLElBQU0sT0FBT3JCLGFBQWEsY0FBY3NCLFNBQVM7UUFDbkU5QixvQkFBb0JHLHFFQUFpQkE7UUFDckNGLHNCQUFzQkcsdUVBQW1CQTtRQUN6Q3VCLFlBQVl0QixnRUFBWUE7UUFDeEIwQixlQUFlLElBQU0sT0FBT3ZCLGFBQWEsY0FBY3NCLE9BQU9FLE9BQU8sR0FBRztRQUN4RSxHQUFHcEIsT0FBTztJQUNaO0FBQ0Y7QUFJRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWludGVydmlld2VyLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9yZWFjdC12aXJ0dWFsL2Rpc3QvZXNtL2luZGV4LmpzPzliZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyBvYnNlcnZlRWxlbWVudFJlY3QsIG9ic2VydmVFbGVtZW50T2Zmc2V0LCBlbGVtZW50U2Nyb2xsLCBvYnNlcnZlV2luZG93UmVjdCwgb2JzZXJ2ZVdpbmRvd09mZnNldCwgd2luZG93U2Nyb2xsLCBWaXJ0dWFsaXplciB9IGZyb20gXCJAdGFuc3RhY2svdmlydHVhbC1jb3JlXCI7XG5leHBvcnQgKiBmcm9tIFwiQHRhbnN0YWNrL3ZpcnR1YWwtY29yZVwiO1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZVZpcnR1YWxpemVyQmFzZShvcHRpb25zKSB7XG4gIGNvbnN0IHJlcmVuZGVyID0gUmVhY3QudXNlUmVkdWNlcigoKSA9PiAoe30pLCB7fSlbMV07XG4gIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG9uQ2hhbmdlOiAoaW5zdGFuY2UyLCBzeW5jKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBmbHVzaFN5bmMocmVyZW5kZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVyZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIChfYSA9IG9wdGlvbnMub25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGluc3RhbmNlMiwgc3luYyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBbaW5zdGFuY2VdID0gUmVhY3QudXNlU3RhdGUoXG4gICAgKCkgPT4gbmV3IFZpcnR1YWxpemVyKHJlc29sdmVkT3B0aW9ucylcbiAgKTtcbiAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhyZXNvbHZlZE9wdGlvbnMpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBpbnN0YW5jZS5fZGlkTW91bnQoKTtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX3dpbGxVcGRhdGUoKTtcbiAgfSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHVzZVZpcnR1YWxpemVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZVZpcnR1YWxpemVyQmFzZSh7XG4gICAgb2JzZXJ2ZUVsZW1lbnRSZWN0LFxuICAgIG9ic2VydmVFbGVtZW50T2Zmc2V0LFxuICAgIHNjcm9sbFRvRm46IGVsZW1lbnRTY3JvbGwsXG4gICAgLi4ub3B0aW9uc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZVdpbmRvd1ZpcnR1YWxpemVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZVZpcnR1YWxpemVyQmFzZSh7XG4gICAgZ2V0U2Nyb2xsRWxlbWVudDogKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbCxcbiAgICBvYnNlcnZlRWxlbWVudFJlY3Q6IG9ic2VydmVXaW5kb3dSZWN0LFxuICAgIG9ic2VydmVFbGVtZW50T2Zmc2V0OiBvYnNlcnZlV2luZG93T2Zmc2V0LFxuICAgIHNjcm9sbFRvRm46IHdpbmRvd1Njcm9sbCxcbiAgICBpbml0aWFsT2Zmc2V0OiAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuc2Nyb2xsWSA6IDAsXG4gICAgLi4ub3B0aW9uc1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIHVzZVZpcnR1YWxpemVyLFxuICB1c2VXaW5kb3dWaXJ0dWFsaXplclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiZmx1c2hTeW5jIiwib2JzZXJ2ZUVsZW1lbnRSZWN0Iiwib2JzZXJ2ZUVsZW1lbnRPZmZzZXQiLCJlbGVtZW50U2Nyb2xsIiwib2JzZXJ2ZVdpbmRvd1JlY3QiLCJvYnNlcnZlV2luZG93T2Zmc2V0Iiwid2luZG93U2Nyb2xsIiwiVmlydHVhbGl6ZXIiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiZG9jdW1lbnQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VWaXJ0dWFsaXplckJhc2UiLCJvcHRpb25zIiwicmVyZW5kZXIiLCJ1c2VSZWR1Y2VyIiwicmVzb2x2ZWRPcHRpb25zIiwib25DaGFuZ2UiLCJpbnN0YW5jZTIiLCJzeW5jIiwiX2EiLCJjYWxsIiwiaW5zdGFuY2UiLCJ1c2VTdGF0ZSIsInNldE9wdGlvbnMiLCJfZGlkTW91bnQiLCJfd2lsbFVwZGF0ZSIsInVzZVZpcnR1YWxpemVyIiwic2Nyb2xsVG9GbiIsInVzZVdpbmRvd1ZpcnR1YWxpemVyIiwiZ2V0U2Nyb2xsRWxlbWVudCIsIndpbmRvdyIsImluaXRpYWxPZmZzZXQiLCJzY3JvbGxZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst defaultKeyExtractor = (index)=>index;\nconst defaultRangeExtractor = (range)=>{\n    const start = Math.max(range.startIndex - range.overscan, 0);\n    const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n    const arr = [];\n    for(let i = start; i <= end; i++){\n        arr.push(i);\n    }\n    return arr;\n};\nconst observeElementRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    const handler = (rect)=>{\n        const { width, height } = rect;\n        cb({\n            width: Math.round(width),\n            height: Math.round(height)\n        });\n    };\n    handler(element.getBoundingClientRect());\n    if (!targetWindow.ResizeObserver) {\n        return ()=>{};\n    }\n    const observer = new targetWindow.ResizeObserver((entries)=>{\n        const entry = entries[0];\n        if (entry == null ? void 0 : entry.borderBoxSize) {\n            const box = entry.borderBoxSize[0];\n            if (box) {\n                handler({\n                    width: box.inlineSize,\n                    height: box.blockSize\n                });\n                return;\n            }\n        }\n        handler(element.getBoundingClientRect());\n    });\n    observer.observe(element, {\n        box: \"border-box\"\n    });\n    return ()=>{\n        observer.unobserve(element);\n    };\n};\nconst addEventListenerOptions = {\n    passive: true\n};\nconst observeWindowRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb({\n            width: element.innerWidth,\n            height: element.innerHeight\n        });\n    };\n    handler();\n    element.addEventListener(\"resize\", handler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"resize\", handler);\n    };\n};\nconst supportsScrollend =  true ? true : 0;\nconst observeElementOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    let offset = 0;\n    const fallback = instance.options.useScrollendEvent && supportsScrollend ? ()=>void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(targetWindow, ()=>{\n        cb(offset, false);\n    }, instance.options.isScrollingResetDelay);\n    const createHandler = (isScrolling)=>()=>{\n            const { horizontal, isRtl } = instance.options;\n            offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n            fallback();\n            cb(offset, isScrolling);\n        };\n    const handler = createHandler(true);\n    const endHandler = createHandler(false);\n    endHandler();\n    element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n        element.removeEventListener(\"scrollend\", endHandler);\n    };\n};\nconst observeWindowOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    let offset = 0;\n    const fallback = instance.options.useScrollendEvent && supportsScrollend ? ()=>void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(targetWindow, ()=>{\n        cb(offset, false);\n    }, instance.options.isScrollingResetDelay);\n    const createHandler = (isScrolling)=>()=>{\n            offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n            fallback();\n            cb(offset, isScrolling);\n        };\n    const handler = createHandler(true);\n    const endHandler = createHandler(false);\n    endHandler();\n    element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n        element.removeEventListener(\"scrollend\", endHandler);\n    };\n};\nconst measureElement = (element, entry, instance)=>{\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n            const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n            return size;\n        }\n    }\n    return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nconst windowScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nconst elementScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nclass Virtualizer {\n    constructor(opts){\n        this.unsubs = [];\n        this.scrollElement = null;\n        this.targetWindow = null;\n        this.isScrolling = false;\n        this.scrollToIndexTimeoutId = null;\n        this.measurementsCache = [];\n        this.itemSizeCache = /* @__PURE__ */ new Map();\n        this.pendingMeasuredCacheIndexes = [];\n        this.scrollRect = null;\n        this.scrollOffset = null;\n        this.scrollDirection = null;\n        this.scrollAdjustments = 0;\n        this.elementsCache = /* @__PURE__ */ new Map();\n        this.observer = /* @__PURE__ */ (()=>{\n            let _ro = null;\n            const get = ()=>{\n                if (_ro) {\n                    return _ro;\n                }\n                if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n                    return null;\n                }\n                return _ro = new this.targetWindow.ResizeObserver((entries)=>{\n                    entries.forEach((entry)=>{\n                        this._measureElement(entry.target, entry);\n                    });\n                });\n            };\n            return {\n                disconnect: ()=>{\n                    var _a;\n                    (_a = get()) == null ? void 0 : _a.disconnect();\n                    _ro = null;\n                },\n                observe: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.observe(target, {\n                        box: \"border-box\"\n                    });\n                },\n                unobserve: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.unobserve(target);\n                }\n            };\n        })();\n        this.range = null;\n        this.setOptions = (opts2)=>{\n            Object.entries(opts2).forEach(([key, value])=>{\n                if (typeof value === \"undefined\") delete opts2[key];\n            });\n            this.options = {\n                debug: false,\n                initialOffset: 0,\n                overscan: 1,\n                paddingStart: 0,\n                paddingEnd: 0,\n                scrollPaddingStart: 0,\n                scrollPaddingEnd: 0,\n                horizontal: false,\n                getItemKey: defaultKeyExtractor,\n                rangeExtractor: defaultRangeExtractor,\n                onChange: ()=>{},\n                measureElement,\n                initialRect: {\n                    width: 0,\n                    height: 0\n                },\n                scrollMargin: 0,\n                gap: 0,\n                indexAttribute: \"data-index\",\n                initialMeasurementsCache: [],\n                lanes: 1,\n                isScrollingResetDelay: 150,\n                enabled: true,\n                isRtl: false,\n                useScrollendEvent: true,\n                ...opts2\n            };\n        };\n        this.notify = (sync)=>{\n            var _a, _b;\n            (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n        };\n        this.maybeNotify = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>{\n            this.calculateRange();\n            return [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ];\n        }, (isScrolling)=>{\n            this.notify(isScrolling);\n        }, {\n            key:  true && \"maybeNotify\",\n            debug: ()=>this.options.debug,\n            initialDeps: [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ]\n        });\n        this.cleanup = ()=>{\n            this.unsubs.filter(Boolean).forEach((d)=>d());\n            this.unsubs = [];\n            this.observer.disconnect();\n            this.scrollElement = null;\n            this.targetWindow = null;\n        };\n        this._didMount = ()=>{\n            return ()=>{\n                this.cleanup();\n            };\n        };\n        this._willUpdate = ()=>{\n            var _a;\n            const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n            if (this.scrollElement !== scrollElement) {\n                this.cleanup();\n                if (!scrollElement) {\n                    this.maybeNotify();\n                    return;\n                }\n                this.scrollElement = scrollElement;\n                if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n                    this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n                } else {\n                    this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n                }\n                this.elementsCache.forEach((cached)=>{\n                    this.observer.observe(cached);\n                });\n                this._scrollToOffset(this.getScrollOffset(), {\n                    adjustments: void 0,\n                    behavior: void 0\n                });\n                this.unsubs.push(this.options.observeElementRect(this, (rect)=>{\n                    this.scrollRect = rect;\n                    this.maybeNotify();\n                }));\n                this.unsubs.push(this.options.observeElementOffset(this, (offset, isScrolling)=>{\n                    this.scrollAdjustments = 0;\n                    this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n                    this.scrollOffset = offset;\n                    this.isScrolling = isScrolling;\n                    this.maybeNotify();\n                }));\n            }\n        };\n        this.getSize = ()=>{\n            if (!this.options.enabled) {\n                this.scrollRect = null;\n                return 0;\n            }\n            this.scrollRect = this.scrollRect ?? this.options.initialRect;\n            return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n        };\n        this.getScrollOffset = ()=>{\n            if (!this.options.enabled) {\n                this.scrollOffset = null;\n                return 0;\n            }\n            this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n            return this.scrollOffset;\n        };\n        this.getFurthestMeasurement = (measurements, index)=>{\n            const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n            const furthestMeasurements = /* @__PURE__ */ new Map();\n            for(let m = index - 1; m >= 0; m--){\n                const measurement = measurements[m];\n                if (furthestMeasurementsFound.has(measurement.lane)) {\n                    continue;\n                }\n                const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n                if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n                    furthestMeasurements.set(measurement.lane, measurement);\n                } else if (measurement.end < previousFurthestMeasurement.end) {\n                    furthestMeasurementsFound.set(measurement.lane, true);\n                }\n                if (furthestMeasurementsFound.size === this.options.lanes) {\n                    break;\n                }\n            }\n            return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b)=>{\n                if (a.end === b.end) {\n                    return a.index - b.index;\n                }\n                return a.end - b.end;\n            })[0] : void 0;\n        };\n        this.getMeasurementOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.count,\n                this.options.paddingStart,\n                this.options.scrollMargin,\n                this.options.getItemKey,\n                this.options.enabled\n            ], (count, paddingStart, scrollMargin, getItemKey, enabled)=>{\n            this.pendingMeasuredCacheIndexes = [];\n            return {\n                count,\n                paddingStart,\n                scrollMargin,\n                getItemKey,\n                enabled\n            };\n        }, {\n            key: false\n        });\n        this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurementOptions(),\n                this.itemSizeCache\n            ], ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache)=>{\n            if (!enabled) {\n                this.measurementsCache = [];\n                this.itemSizeCache.clear();\n                return [];\n            }\n            if (this.measurementsCache.length === 0) {\n                this.measurementsCache = this.options.initialMeasurementsCache;\n                this.measurementsCache.forEach((item)=>{\n                    this.itemSizeCache.set(item.key, item.size);\n                });\n            }\n            const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n            this.pendingMeasuredCacheIndexes = [];\n            const measurements = this.measurementsCache.slice(0, min);\n            for(let i = min; i < count; i++){\n                const key = getItemKey(i);\n                const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n                const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n                const measuredSize = itemSizeCache.get(key);\n                const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n                const end = start + size;\n                const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n                measurements[i] = {\n                    index: i,\n                    start,\n                    size,\n                    end,\n                    key,\n                    lane\n                };\n            }\n            this.measurementsCache = measurements;\n            return measurements;\n        }, {\n            key:  true && \"getMeasurements\",\n            debug: ()=>this.options.debug\n        });\n        this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurements(),\n                this.getSize(),\n                this.getScrollOffset()\n            ], (measurements, outerSize, scrollOffset)=>{\n            return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n                measurements,\n                outerSize,\n                scrollOffset\n            }) : null;\n        }, {\n            key:  true && \"calculateRange\",\n            debug: ()=>this.options.debug\n        });\n        this.getIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.rangeExtractor,\n                this.calculateRange(),\n                this.options.overscan,\n                this.options.count\n            ], (rangeExtractor, range, overscan, count)=>{\n            return range === null ? [] : rangeExtractor({\n                startIndex: range.startIndex,\n                endIndex: range.endIndex,\n                overscan,\n                count\n            });\n        }, {\n            key:  true && \"getIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.indexFromElement = (node)=>{\n            const attributeName = this.options.indexAttribute;\n            const indexStr = node.getAttribute(attributeName);\n            if (!indexStr) {\n                console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n                return -1;\n            }\n            return parseInt(indexStr, 10);\n        };\n        this._measureElement = (node, entry)=>{\n            const index = this.indexFromElement(node);\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return;\n            }\n            const key = item.key;\n            const prevNode = this.elementsCache.get(key);\n            if (prevNode !== node) {\n                if (prevNode) {\n                    this.observer.unobserve(prevNode);\n                }\n                this.observer.observe(node);\n                this.elementsCache.set(key, node);\n            }\n            if (node.isConnected) {\n                this.resizeItem(index, this.options.measureElement(node, entry, this));\n            }\n        };\n        this.resizeItem = (index, size)=>{\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return;\n            }\n            const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n            const delta = size - itemSize;\n            if (delta !== 0) {\n                if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n                    if ( true && this.options.debug) {\n                        console.info(\"correction\", delta);\n                    }\n                    this._scrollToOffset(this.getScrollOffset(), {\n                        adjustments: this.scrollAdjustments += delta,\n                        behavior: void 0\n                    });\n                }\n                this.pendingMeasuredCacheIndexes.push(item.index);\n                this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n                this.notify(false);\n            }\n        };\n        this.measureElement = (node)=>{\n            if (!node) {\n                this.elementsCache.forEach((cached, key)=>{\n                    if (!cached.isConnected) {\n                        this.observer.unobserve(cached);\n                        this.elementsCache.delete(key);\n                    }\n                });\n                return;\n            }\n            this._measureElement(node, void 0);\n        };\n        this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getIndexes(),\n                this.getMeasurements()\n            ], (indexes, measurements)=>{\n            const virtualItems = [];\n            for(let k = 0, len = indexes.length; k < len; k++){\n                const i = indexes[k];\n                const measurement = measurements[i];\n                virtualItems.push(measurement);\n            }\n            return virtualItems;\n        }, {\n            key:  true && \"getVirtualItems\",\n            debug: ()=>this.options.debug\n        });\n        this.getVirtualItemForOffset = (offset)=>{\n            const measurements = this.getMeasurements();\n            if (measurements.length === 0) {\n                return void 0;\n            }\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[findNearestBinarySearch(0, measurements.length - 1, (index)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start, offset)]);\n        };\n        this.getOffsetForAlignment = (toOffset, align)=>{\n            const size = this.getSize();\n            const scrollOffset = this.getScrollOffset();\n            if (align === \"auto\") {\n                if (toOffset <= scrollOffset) {\n                    align = \"start\";\n                } else if (toOffset >= scrollOffset + size) {\n                    align = \"end\";\n                } else {\n                    align = \"start\";\n                }\n            }\n            if (align === \"start\") {\n                toOffset = toOffset;\n            } else if (align === \"end\") {\n                toOffset = toOffset - size;\n            } else if (align === \"center\") {\n                toOffset = toOffset - size / 2;\n            }\n            const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n            const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n            const maxOffset = scrollSize - size;\n            return Math.max(Math.min(maxOffset, toOffset), 0);\n        };\n        this.getOffsetForIndex = (index, align = \"auto\")=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return void 0;\n            }\n            const size = this.getSize();\n            const scrollOffset = this.getScrollOffset();\n            if (align === \"auto\") {\n                if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n                    align = \"end\";\n                } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n                    align = \"start\";\n                } else {\n                    return [\n                        scrollOffset,\n                        align\n                    ];\n                }\n            }\n            const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n            return [\n                this.getOffsetForAlignment(toOffset, align),\n                align\n            ];\n        };\n        this.isDynamicMode = ()=>this.elementsCache.size > 0;\n        this.cancelScrollToIndex = ()=>{\n            if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n                this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n                this.scrollToIndexTimeoutId = null;\n            }\n        };\n        this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {})=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);\n            if (!offsetAndAlign) return;\n            const [offset, align] = offsetAndAlign;\n            this._scrollToOffset(offset, {\n                adjustments: void 0,\n                behavior\n            });\n            if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n                this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(()=>{\n                    this.scrollToIndexTimeoutId = null;\n                    const elementInDOM = this.elementsCache.has(this.options.getItemKey(index));\n                    if (elementInDOM) {\n                        const [latestOffset] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(this.getOffsetForIndex(index, align));\n                        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(latestOffset, this.getScrollOffset())) {\n                            this.scrollToIndex(index, {\n                                align,\n                                behavior\n                            });\n                        }\n                    } else {\n                        this.scrollToIndex(index, {\n                            align,\n                            behavior\n                        });\n                    }\n                });\n            }\n        };\n        this.scrollBy = (delta, { behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getScrollOffset() + delta, {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.getTotalSize = ()=>{\n            var _a;\n            const measurements = this.getMeasurements();\n            let end;\n            if (measurements.length === 0) {\n                end = this.options.paddingStart;\n            } else {\n                end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(...measurements.slice(-this.options.lanes).map((m)=>m.end));\n            }\n            return Math.max(end - this.options.scrollMargin + this.options.paddingEnd, 0);\n        };\n        this._scrollToOffset = (offset, { adjustments, behavior })=>{\n            this.options.scrollToFn(offset, {\n                behavior,\n                adjustments\n            }, this);\n        };\n        this.measure = ()=>{\n            this.itemSizeCache = /* @__PURE__ */ new Map();\n            this.notify(false);\n        };\n        this.setOptions(opts);\n    }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value)=>{\n    while(low <= high){\n        const middle = (low + high) / 2 | 0;\n        const currentValue = getCurrentValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        } else if (currentValue > value) {\n            high = middle - 1;\n        } else {\n            return middle;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n    const count = measurements.length - 1;\n    const getOffset = (index)=>measurements[index].start;\n    const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n    let endIndex = startIndex;\n    while(endIndex < count && measurements[endIndex].end < scrollOffset + outerSize){\n        endIndex++;\n    }\n    return {\n        startIndex,\n        endIndex\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDdkUsTUFBTUksc0JBQXNCLENBQUNDLFFBQVVBO0FBQ3ZDLE1BQU1DLHdCQUF3QixDQUFDQztJQUM3QixNQUFNQyxRQUFRQyxLQUFLQyxHQUFHLENBQUNILE1BQU1JLFVBQVUsR0FBR0osTUFBTUssUUFBUSxFQUFFO0lBQzFELE1BQU1DLE1BQU1KLEtBQUtLLEdBQUcsQ0FBQ1AsTUFBTVEsUUFBUSxHQUFHUixNQUFNSyxRQUFRLEVBQUVMLE1BQU1TLEtBQUssR0FBRztJQUNwRSxNQUFNQyxNQUFNLEVBQUU7SUFDZCxJQUFLLElBQUlDLElBQUlWLE9BQU9VLEtBQUtMLEtBQUtLLElBQUs7UUFDakNELElBQUlFLElBQUksQ0FBQ0Q7SUFDWDtJQUNBLE9BQU9EO0FBQ1Q7QUFDQSxNQUFNRyxxQkFBcUIsQ0FBQ0MsVUFBVUM7SUFDcEMsTUFBTUMsVUFBVUYsU0FBU0csYUFBYTtJQUN0QyxJQUFJLENBQUNELFNBQVM7UUFDWjtJQUNGO0lBQ0EsTUFBTUUsZUFBZUosU0FBU0ksWUFBWTtJQUMxQyxJQUFJLENBQUNBLGNBQWM7UUFDakI7SUFDRjtJQUNBLE1BQU1DLFVBQVUsQ0FBQ0M7UUFDZixNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdGO1FBQzFCTCxHQUFHO1lBQUVNLE9BQU9uQixLQUFLcUIsS0FBSyxDQUFDRjtZQUFRQyxRQUFRcEIsS0FBS3FCLEtBQUssQ0FBQ0Q7UUFBUTtJQUM1RDtJQUNBSCxRQUFRSCxRQUFRUSxxQkFBcUI7SUFDckMsSUFBSSxDQUFDTixhQUFhTyxjQUFjLEVBQUU7UUFDaEMsT0FBTyxLQUNQO0lBQ0Y7SUFDQSxNQUFNQyxXQUFXLElBQUlSLGFBQWFPLGNBQWMsQ0FBQyxDQUFDRTtRQUNoRCxNQUFNQyxRQUFRRCxPQUFPLENBQUMsRUFBRTtR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QjZHLE1BQU1HLFNBQVM7UUFDakIsT0FBTyxJQUFJQyxlQUFlakgsT0FBTztZQUMvQjhHLE9BQU9FLFNBQVM7UUFDbEIsT0FBTztZQUNMLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBLElBQUlILE1BQU0sR0FBRztRQUNYLE9BQU9BLE1BQU07SUFDZixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFDQSxTQUFTekYsZUFBZSxFQUN0QmlCLFlBQVksRUFDWndCLFNBQVMsRUFDVDNFLFlBQVksRUFDYjtJQUNDLE1BQU1wRSxRQUFRdUgsYUFBYWtCLE1BQU0sR0FBRztJQUNwQyxNQUFNMkQsWUFBWSxDQUFDL00sUUFBVWtJLFlBQVksQ0FBQ2xJLE1BQU0sQ0FBQ0csS0FBSztJQUN0RCxNQUFNRyxhQUFhNEssd0JBQXdCLEdBQUd2SyxPQUFPb00sV0FBV2hJO0lBQ2hFLElBQUlyRSxXQUFXSjtJQUNmLE1BQU9JLFdBQVdDLFNBQVN1SCxZQUFZLENBQUN4SCxTQUFTLENBQUNGLEdBQUcsR0FBR3VFLGVBQWUyRSxVQUFXO1FBQ2hGaEo7SUFDRjtJQUNBLE9BQU87UUFBRUo7UUFBWUk7SUFBUztBQUNoQztBQWdCRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWludGVydmlld2VyLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvZGlzdC9lc20vaW5kZXguanM/YjY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWJvdW5jZSwgbWVtbywgbm90VW5kZWZpbmVkLCBhcHByb3hFcXVhbCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5jb25zdCBkZWZhdWx0S2V5RXh0cmFjdG9yID0gKGluZGV4KSA9PiBpbmRleDtcbmNvbnN0IGRlZmF1bHRSYW5nZUV4dHJhY3RvciA9IChyYW5nZSkgPT4ge1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0SW5kZXggLSByYW5nZS5vdmVyc2NhbiwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHJhbmdlLmVuZEluZGV4ICsgcmFuZ2Uub3ZlcnNjYW4sIHJhbmdlLmNvdW50IC0gMSk7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBhcnIucHVzaChpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbmNvbnN0IG9ic2VydmVFbGVtZW50UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAocmVjdCkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBjYih7IHdpZHRoOiBNYXRoLnJvdW5kKHdpZHRoKSwgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodCkgfSk7XG4gIH07XG4gIGhhbmRsZXIoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIGlmICghdGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IHRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBpZiAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmJvcmRlckJveFNpemUpIHtcbiAgICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgICBpZiAoYm94KSB7XG4gICAgICAgIGhhbmRsZXIoeyB3aWR0aDogYm94LmlubGluZVNpemUsIGhlaWdodDogYm94LmJsb2NrU2l6ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVyKGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICB9O1xufTtcbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuY29uc3Qgb2JzZXJ2ZVdpbmRvd1JlY3QgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICBjYih7IHdpZHRoOiBlbGVtZW50LmlubmVyV2lkdGgsIGhlaWdodDogZWxlbWVudC5pbm5lckhlaWdodCB9KTtcbiAgfTtcbiAgaGFuZGxlcigpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyKTtcbiAgfTtcbn07XG5jb25zdCBzdXBwb3J0c1Njcm9sbGVuZCA9IHR5cGVvZiB3aW5kb3cgPT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBcIm9uc2Nyb2xsZW5kXCIgaW4gd2luZG93O1xuY29uc3Qgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gaW5zdGFuY2UudGFyZ2V0V2luZG93O1xuICBpZiAoIXRhcmdldFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmFsbGJhY2sgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kID8gKCkgPT4gdm9pZCAwIDogZGVib3VuY2UoXG4gICAgdGFyZ2V0V2luZG93LFxuICAgICgpID0+IHtcbiAgICAgIGNiKG9mZnNldCwgZmFsc2UpO1xuICAgIH0sXG4gICAgaW5zdGFuY2Uub3B0aW9ucy5pc1Njcm9sbGluZ1Jlc2V0RGVsYXlcbiAgKTtcbiAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChpc1Njcm9sbGluZykgPT4gKCkgPT4ge1xuICAgIGNvbnN0IHsgaG9yaXpvbnRhbCwgaXNSdGwgfSA9IGluc3RhbmNlLm9wdGlvbnM7XG4gICAgb2Zmc2V0ID0gaG9yaXpvbnRhbCA/IGVsZW1lbnRbXCJzY3JvbGxMZWZ0XCJdICogKGlzUnRsICYmIC0xIHx8IDEpIDogZWxlbWVudFtcInNjcm9sbFRvcFwiXTtcbiAgICBmYWxsYmFjaygpO1xuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpO1xuICB9O1xuICBjb25zdCBoYW5kbGVyID0gY3JlYXRlSGFuZGxlcih0cnVlKTtcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpO1xuICBlbmRIYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIpO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgfTtcbn07XG5jb25zdCBvYnNlcnZlV2luZG93T2Zmc2V0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IGluc3RhbmNlLnRhcmdldFdpbmRvdztcbiAgaWYgKCF0YXJnZXRXaW5kb3cpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZhbGxiYWNrID0gaW5zdGFuY2Uub3B0aW9ucy51c2VTY3JvbGxlbmRFdmVudCAmJiBzdXBwb3J0c1Njcm9sbGVuZCA/ICgpID0+IHZvaWQgMCA6IGRlYm91bmNlKFxuICAgIHRhcmdldFdpbmRvdyxcbiAgICAoKSA9PiB7XG4gICAgICBjYihvZmZzZXQsIGZhbHNlKTtcbiAgICB9LFxuICAgIGluc3RhbmNlLm9wdGlvbnMuaXNTY3JvbGxpbmdSZXNldERlbGF5XG4gICk7XG4gIGNvbnN0IGNyZWF0ZUhhbmRsZXIgPSAoaXNTY3JvbGxpbmcpID0+ICgpID0+IHtcbiAgICBvZmZzZXQgPSBlbGVtZW50W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwic2Nyb2xsWFwiIDogXCJzY3JvbGxZXCJdO1xuICAgIGZhbGxiYWNrKCk7XG4gICAgY2Iob2Zmc2V0LCBpc1Njcm9sbGluZyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKHRydWUpO1xuICBjb25zdCBlbmRIYW5kbGVyID0gY3JlYXRlSGFuZGxlcihmYWxzZSk7XG4gIGVuZEhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIpO1xuICB9O1xufTtcbmNvbnN0IG1lYXN1cmVFbGVtZW50ID0gKGVsZW1lbnQsIGVudHJ5LCBpbnN0YW5jZSkgPT4ge1xuICBpZiAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmJvcmRlckJveFNpemUpIHtcbiAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgIGlmIChib3gpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBNYXRoLnJvdW5kKFxuICAgICAgICBib3hbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJpbmxpbmVTaXplXCIgOiBcImJsb2NrU2l6ZVwiXVxuICAgICAgKTtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdXG4gICk7XG59O1xuY29uc3Qgd2luZG93U2Nyb2xsID0gKG9mZnNldCwge1xuICBhZGp1c3RtZW50cyA9IDAsXG4gIGJlaGF2aW9yXG59LCBpbnN0YW5jZSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2IgPSAoX2EgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2Nyb2xsVG8pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl06IHRvT2Zmc2V0LFxuICAgIGJlaGF2aW9yXG4gIH0pO1xufTtcbmNvbnN0IGVsZW1lbnRTY3JvbGwgPSAob2Zmc2V0LCB7XG4gIGFkanVzdG1lbnRzID0gMCxcbiAgYmVoYXZpb3Jcbn0sIGluc3RhbmNlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHRvT2Zmc2V0ID0gb2Zmc2V0ICsgYWRqdXN0bWVudHM7XG4gIChfYiA9IChfYSA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY3JvbGxUbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICBbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogdG9PZmZzZXQsXG4gICAgYmVoYXZpb3JcbiAgfSk7XG59O1xuY2xhc3MgVmlydHVhbGl6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy51bnN1YnMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0V2luZG93ID0gbnVsbDtcbiAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gW107XG4gICAgdGhpcy5pdGVtU2l6ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsUmVjdCA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMDtcbiAgICB0aGlzLmVsZW1lbnRzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICAgIGxldCBfcm8gPSBudWxsO1xuICAgICAgY29uc3QgZ2V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoX3JvKSB7XG4gICAgICAgICAgcmV0dXJuIF9ybztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0V2luZG93IHx8ICF0aGlzLnRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcm8gPSBuZXcgdGhpcy50YXJnZXRXaW5kb3cuUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBfcm8gPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm9ic2VydmUodGFyZ2V0LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVub2JzZXJ2ZTogKHRhcmdldCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gKF9hID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHRoaXMucmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuc2V0T3B0aW9ucyA9IChvcHRzMikgPT4ge1xuICAgICAgT2JqZWN0LmVudHJpZXMob3B0czIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSBkZWxldGUgb3B0czJba2V5XTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWxPZmZzZXQ6IDAsXG4gICAgICAgIG92ZXJzY2FuOiAxLFxuICAgICAgICBwYWRkaW5nU3RhcnQ6IDAsXG4gICAgICAgIHBhZGRpbmdFbmQ6IDAsXG4gICAgICAgIHNjcm9sbFBhZGRpbmdTdGFydDogMCxcbiAgICAgICAgc2Nyb2xsUGFkZGluZ0VuZDogMCxcbiAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIGdldEl0ZW1LZXk6IGRlZmF1bHRLZXlFeHRyYWN0b3IsXG4gICAgICAgIHJhbmdlRXh0cmFjdG9yOiBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG1lYXN1cmVFbGVtZW50LFxuICAgICAgICBpbml0aWFsUmVjdDogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIHNjcm9sbE1hcmdpbjogMCxcbiAgICAgICAgZ2FwOiAwLFxuICAgICAgICBpbmRleEF0dHJpYnV0ZTogXCJkYXRhLWluZGV4XCIsXG4gICAgICAgIGluaXRpYWxNZWFzdXJlbWVudHNDYWNoZTogW10sXG4gICAgICAgIGxhbmVzOiAxLFxuICAgICAgICBpc1Njcm9sbGluZ1Jlc2V0RGVsYXk6IDE1MCxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgaXNSdGw6IGZhbHNlLFxuICAgICAgICB1c2VTY3JvbGxlbmRFdmVudDogdHJ1ZSxcbiAgICAgICAgLi4ub3B0czJcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLm5vdGlmeSA9IChzeW5jKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMsIHN5bmMpO1xuICAgIH07XG4gICAgdGhpcy5tYXliZU5vdGlmeSA9IG1lbW8oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLnN0YXJ0SW5kZXggOiBudWxsLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbFxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIChpc1Njcm9sbGluZykgPT4ge1xuICAgICAgICB0aGlzLm5vdGlmeShpc1Njcm9sbGluZyk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcIm1heWJlTm90aWZ5XCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWcsXG4gICAgICAgIGluaXRpYWxEZXBzOiBbXG4gICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5zdGFydEluZGV4IDogbnVsbCxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5lbmRJbmRleCA6IG51bGxcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5fZGlkTW91bnQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLl93aWxsVXBkYXRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMub3B0aW9ucy5lbmFibGVkID8gdGhpcy5vcHRpb25zLmdldFNjcm9sbEVsZW1lbnQoKSA6IG51bGw7XG4gICAgICBpZiAodGhpcy5zY3JvbGxFbGVtZW50ICE9PSBzY3JvbGxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICBpZiAoIXNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEVsZW1lbnQgJiYgXCJvd25lckRvY3VtZW50XCIgaW4gdGhpcy5zY3JvbGxFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFdpbmRvdyA9ICgoX2EgPSB0aGlzLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS53aW5kb3cpID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShjYWNoZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRTY3JvbGxPZmZzZXQoKSwge1xuICAgICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnN1YnMucHVzaChcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRSZWN0KHRoaXMsIChyZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgdGhpcy5tYXliZU5vdGlmeSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudW5zdWJzLnB1c2goXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9ic2VydmVFbGVtZW50T2Zmc2V0KHRoaXMsIChvZmZzZXQsIGlzU2Nyb2xsaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gaXNTY3JvbGxpbmcgPyB0aGlzLmdldFNjcm9sbE9mZnNldCgpIDwgb2Zmc2V0ID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gaXNTY3JvbGxpbmc7XG4gICAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNjcm9sbFJlY3QgPSB0aGlzLnNjcm9sbFJlY3QgPz8gdGhpcy5vcHRpb25zLmluaXRpYWxSZWN0O1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUmVjdFt0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdO1xuICAgIH07XG4gICAgdGhpcy5nZXRTY3JvbGxPZmZzZXQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHRoaXMuc2Nyb2xsT2Zmc2V0ID8/ICh0eXBlb2YgdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0KCkgOiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxPZmZzZXQ7XG4gICAgfTtcbiAgICB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQgPSAobWVhc3VyZW1lbnRzLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCBtID0gaW5kZXggLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1ttXTtcbiAgICAgICAgaWYgKGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuaGFzKG1lYXN1cmVtZW50LmxhbmUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID0gZnVydGhlc3RNZWFzdXJlbWVudHMuZ2V0KFxuICAgICAgICAgIG1lYXN1cmVtZW50LmxhbmVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCA9PSBudWxsIHx8IG1lYXN1cmVtZW50LmVuZCA+IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgICBmdXJ0aGVzdE1lYXN1cmVtZW50cy5zZXQobWVhc3VyZW1lbnQubGFuZSwgbWVhc3VyZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lYXN1cmVtZW50LmVuZCA8IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgICBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNldChtZWFzdXJlbWVudC5sYW5lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zaXplID09PSB0aGlzLm9wdGlvbnMubGFuZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcyA/IEFycmF5LmZyb20oZnVydGhlc3RNZWFzdXJlbWVudHMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEuZW5kID09PSBiLmVuZCkge1xuICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5lbmQgLSBiLmVuZDtcbiAgICAgIH0pWzBdIDogdm9pZCAwO1xuICAgIH07XG4gICAgdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4sXG4gICAgICAgIHRoaXMub3B0aW9ucy5nZXRJdGVtS2V5LFxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZFxuICAgICAgXSxcbiAgICAgIChjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXksIGVuYWJsZWQpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb3VudCxcbiAgICAgICAgICBwYWRkaW5nU3RhcnQsXG4gICAgICAgICAgc2Nyb2xsTWFyZ2luLFxuICAgICAgICAgIGdldEl0ZW1LZXksXG4gICAgICAgICAgZW5hYmxlZFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBmYWxzZVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5nZXRNZWFzdXJlbWVudHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0TWVhc3VyZW1lbnRPcHRpb25zKCksIHRoaXMuaXRlbVNpemVDYWNoZV0sXG4gICAgICAoeyBjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXksIGVuYWJsZWQgfSwgaXRlbVNpemVDYWNoZSkgPT4ge1xuICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gW107XG4gICAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVtZW50c0NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSB0aGlzLm9wdGlvbnMuaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlO1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgaXRlbS5zaXplKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5sZW5ndGggPiAwID8gTWF0aC5taW4oLi4udGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMpIDogMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5zbGljZSgwLCBtaW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gbWluOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGdldEl0ZW1LZXkoaSk7XG4gICAgICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudCA9IHRoaXMub3B0aW9ucy5sYW5lcyA9PT0gMSA/IG1lYXN1cmVtZW50c1tpIC0gMV0gOiB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQobWVhc3VyZW1lbnRzLCBpKTtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCArIHRoaXMub3B0aW9ucy5nYXAgOiBwYWRkaW5nU3RhcnQgKyBzY3JvbGxNYXJnaW47XG4gICAgICAgICAgY29uc3QgbWVhc3VyZWRTaXplID0gaXRlbVNpemVDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICBjb25zdCBzaXplID0gdHlwZW9mIG1lYXN1cmVkU2l6ZSA9PT0gXCJudW1iZXJcIiA/IG1lYXN1cmVkU2l6ZSA6IHRoaXMub3B0aW9ucy5lc3RpbWF0ZVNpemUoaSk7XG4gICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBzaXplO1xuICAgICAgICAgIGNvbnN0IGxhbmUgPSBmdXJ0aGVzdE1lYXN1cmVtZW50ID8gZnVydGhlc3RNZWFzdXJlbWVudC5sYW5lIDogaSAlIHRoaXMub3B0aW9ucy5sYW5lcztcbiAgICAgICAgICBtZWFzdXJlbWVudHNbaV0gPSB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBtZWFzdXJlbWVudHM7XG4gICAgICAgIHJldHVybiBtZWFzdXJlbWVudHM7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldE1lYXN1cmVtZW50c1wiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmNhbGN1bGF0ZVJhbmdlID0gbWVtbyhcbiAgICAgICgpID0+IFt0aGlzLmdldE1lYXN1cmVtZW50cygpLCB0aGlzLmdldFNpemUoKSwgdGhpcy5nZXRTY3JvbGxPZmZzZXQoKV0sXG4gICAgICAobWVhc3VyZW1lbnRzLCBvdXRlclNpemUsIHNjcm9sbE9mZnNldCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSA9IG1lYXN1cmVtZW50cy5sZW5ndGggPiAwICYmIG91dGVyU2l6ZSA+IDAgPyBjYWxjdWxhdGVSYW5nZSh7XG4gICAgICAgICAgbWVhc3VyZW1lbnRzLFxuICAgICAgICAgIG91dGVyU2l6ZSxcbiAgICAgICAgICBzY3JvbGxPZmZzZXRcbiAgICAgICAgfSkgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJjYWxjdWxhdGVSYW5nZVwiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldEluZGV4ZXMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLm9wdGlvbnMucmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UoKSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJzY2FuLFxuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnRcbiAgICAgIF0sXG4gICAgICAocmFuZ2VFeHRyYWN0b3IsIHJhbmdlLCBvdmVyc2NhbiwgY291bnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJhbmdlID09PSBudWxsID8gW10gOiByYW5nZUV4dHJhY3Rvcih7XG4gICAgICAgICAgc3RhcnRJbmRleDogcmFuZ2Uuc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleDogcmFuZ2UuZW5kSW5kZXgsXG4gICAgICAgICAgb3ZlcnNjYW4sXG4gICAgICAgICAgY291bnRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldEluZGV4ZXNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5pbmRleEZyb21FbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLm9wdGlvbnMuaW5kZXhBdHRyaWJ1dGU7XG4gICAgICBjb25zdCBpbmRleFN0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKCFpbmRleFN0cikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYE1pc3NpbmcgYXR0cmlidXRlIG5hbWUgJyR7YXR0cmlidXRlTmFtZX09e2luZGV4fScgb24gbWVhc3VyZWQgZWxlbWVudC5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUludChpbmRleFN0ciwgMTApO1xuICAgIH07XG4gICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSAobm9kZSwgZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleEZyb21FbGVtZW50KG5vZGUpO1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLmVsZW1lbnRzQ2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAocHJldk5vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUocHJldk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShub2RlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLnNldChrZXksIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVJdGVtKGluZGV4LCB0aGlzLm9wdGlvbnMubWVhc3VyZUVsZW1lbnQobm9kZSwgZW50cnksIHRoaXMpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVzaXplSXRlbSA9IChpbmRleCwgc2l6ZSkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZUNhY2hlLmdldChpdGVtLmtleSkgPz8gaXRlbS5zaXplO1xuICAgICAgY29uc3QgZGVsdGEgPSBzaXplIC0gaXRlbVNpemU7XG4gICAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQWRqdXN0U2Nyb2xsUG9zaXRpb25Pbkl0ZW1TaXplQ2hhbmdlICE9PSB2b2lkIDAgPyB0aGlzLnNob3VsZEFkanVzdFNjcm9sbFBvc2l0aW9uT25JdGVtU2l6ZUNoYW5nZShpdGVtLCBkZWx0YSwgdGhpcykgOiBpdGVtLnN0YXJ0IDwgdGhpcy5nZXRTY3JvbGxPZmZzZXQoKSArIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiY29ycmVjdGlvblwiLCBkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCksIHtcbiAgICAgICAgICAgIGFkanVzdG1lbnRzOiB0aGlzLnNjcm9sbEFkanVzdG1lbnRzICs9IGRlbHRhLFxuICAgICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLnB1c2goaXRlbS5pbmRleCk7XG4gICAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IG5ldyBNYXAodGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgc2l6ZSkpO1xuICAgICAgICB0aGlzLm5vdGlmeShmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmVFbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZm9yRWFjaCgoY2FjaGVkLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoIWNhY2hlZC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUoY2FjaGVkKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChub2RlLCB2b2lkIDApO1xuICAgIH07XG4gICAgdGhpcy5nZXRWaXJ0dWFsSXRlbXMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0SW5kZXhlcygpLCB0aGlzLmdldE1lYXN1cmVtZW50cygpXSxcbiAgICAgIChpbmRleGVzLCBtZWFzdXJlbWVudHMpID0+IHtcbiAgICAgICAgY29uc3QgdmlydHVhbEl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBpbmRleGVzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgY29uc3QgaSA9IGluZGV4ZXNba107XG4gICAgICAgICAgY29uc3QgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgICAgICAgdmlydHVhbEl0ZW1zLnB1c2gobWVhc3VyZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXJ0dWFsSXRlbXM7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldFZpcnR1YWxJdGVtc1wiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldFZpcnR1YWxJdGVtRm9yT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5nZXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIGlmIChtZWFzdXJlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90VW5kZWZpbmVkKFxuICAgICAgICBtZWFzdXJlbWVudHNbZmluZE5lYXJlc3RCaW5hcnlTZWFyY2goXG4gICAgICAgICAgMCxcbiAgICAgICAgICBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAoaW5kZXgpID0+IG5vdFVuZGVmaW5lZChtZWFzdXJlbWVudHNbaW5kZXhdKS5zdGFydCxcbiAgICAgICAgICBvZmZzZXRcbiAgICAgICAgKV1cbiAgICAgICk7XG4gICAgfTtcbiAgICB0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCA9ICh0b09mZnNldCwgYWxpZ24pID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICBpZiAoYWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGlmICh0b09mZnNldCA8PSBzY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwic3RhcnRcIjtcbiAgICAgICAgfSBlbHNlIGlmICh0b09mZnNldCA+PSBzY3JvbGxPZmZzZXQgKyBzaXplKSB7XG4gICAgICAgICAgYWxpZ24gPSBcImVuZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWxpZ24gPT09IFwic3RhcnRcIikge1xuICAgICAgICB0b09mZnNldCA9IHRvT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJlbmRcIikge1xuICAgICAgICB0b09mZnNldCA9IHRvT2Zmc2V0IC0gc2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgdG9PZmZzZXQgPSB0b09mZnNldCAtIHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsU2l6ZVByb3AgPSB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwic2Nyb2xsV2lkdGhcIiA6IFwic2Nyb2xsSGVpZ2h0XCI7XG4gICAgICBjb25zdCBzY3JvbGxTaXplID0gdGhpcy5zY3JvbGxFbGVtZW50ID8gXCJkb2N1bWVudFwiIGluIHRoaXMuc2Nyb2xsRWxlbWVudCA/IHRoaXMuc2Nyb2xsRWxlbWVudC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbc2Nyb2xsU2l6ZVByb3BdIDogdGhpcy5zY3JvbGxFbGVtZW50W3Njcm9sbFNpemVQcm9wXSA6IDA7XG4gICAgICBjb25zdCBtYXhPZmZzZXQgPSBzY3JvbGxTaXplIC0gc2l6ZTtcbiAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihtYXhPZmZzZXQsIHRvT2Zmc2V0KSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLmdldE9mZnNldEZvckluZGV4ID0gKGluZGV4LCBhbGlnbiA9IFwiYXV0b1wiKSA9PiB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLm9wdGlvbnMuY291bnQgLSAxKSk7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZVtpbmRleF07XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICBpZiAoYWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGlmIChpdGVtLmVuZCA+PSBzY3JvbGxPZmZzZXQgKyBzaXplIC0gdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5zdGFydCA8PSBzY3JvbGxPZmZzZXQgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0KSB7XG4gICAgICAgICAgYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtzY3JvbGxPZmZzZXQsIGFsaWduXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdG9PZmZzZXQgPSBhbGlnbiA9PT0gXCJlbmRcIiA/IGl0ZW0uZW5kICsgdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQgOiBpdGVtLnN0YXJ0IC0gdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydDtcbiAgICAgIHJldHVybiBbdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQodG9PZmZzZXQsIGFsaWduKSwgYWxpZ25dO1xuICAgIH07XG4gICAgdGhpcy5pc0R5bmFtaWNNb2RlID0gKCkgPT4gdGhpcy5lbGVtZW50c0NhY2hlLnNpemUgPiAwO1xuICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgIT09IG51bGwgJiYgdGhpcy50YXJnZXRXaW5kb3cpIHtcbiAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvT2Zmc2V0ID0gKHRvT2Zmc2V0LCB7IGFsaWduID0gXCJzdGFydFwiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQodG9PZmZzZXQsIGFsaWduKSwge1xuICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvSW5kZXggPSAoaW5kZXgsIHsgYWxpZ246IGluaXRpYWxBbGlnbiA9IFwiYXV0b1wiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0QW5kQWxpZ24gPSB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBpbml0aWFsQWxpZ24pO1xuICAgICAgaWYgKCFvZmZzZXRBbmRBbGlnbikgcmV0dXJuO1xuICAgICAgY29uc3QgW29mZnNldCwgYWxpZ25dID0gb2Zmc2V0QW5kQWxpZ247XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldChvZmZzZXQsIHsgYWRqdXN0bWVudHM6IHZvaWQgMCwgYmVoYXZpb3IgfSk7XG4gICAgICBpZiAoYmVoYXZpb3IgIT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkgJiYgdGhpcy50YXJnZXRXaW5kb3cpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gdGhpcy50YXJnZXRXaW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICBjb25zdCBlbGVtZW50SW5ET00gPSB0aGlzLmVsZW1lbnRzQ2FjaGUuaGFzKFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXkoaW5kZXgpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZWxlbWVudEluRE9NKSB7XG4gICAgICAgICAgICBjb25zdCBbbGF0ZXN0T2Zmc2V0XSA9IG5vdFVuZGVmaW5lZChcbiAgICAgICAgICAgICAgdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgYWxpZ24pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFhcHByb3hFcXVhbChsYXRlc3RPZmZzZXQsIHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwgeyBhbGlnbiwgYmVoYXZpb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwgeyBhbGlnbiwgYmVoYXZpb3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsQnkgPSAoZGVsdGEsIHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgKyBkZWx0YSwge1xuICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmdldFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBsZXQgZW5kO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZW5kID0gdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRoaXMub3B0aW9ucy5sYW5lcyA9PT0gMSA/ICgoX2EgPSBtZWFzdXJlbWVudHNbbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW5kKSA/PyAwIDogTWF0aC5tYXgoXG4gICAgICAgICAgLi4ubWVhc3VyZW1lbnRzLnNsaWNlKC10aGlzLm9wdGlvbnMubGFuZXMpLm1hcCgobSkgPT4gbS5lbmQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgIGVuZCAtIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4gKyB0aGlzLm9wdGlvbnMucGFkZGluZ0VuZCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9O1xuICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0ID0gKG9mZnNldCwge1xuICAgICAgYWRqdXN0bWVudHMsXG4gICAgICBiZWhhdmlvclxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxUb0ZuKG9mZnNldCwgeyBiZWhhdmlvciwgYWRqdXN0bWVudHMgfSwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub3RpZnkoZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdHMpO1xuICB9XG59XG5jb25zdCBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCA9IChsb3csIGhpZ2gsIGdldEN1cnJlbnRWYWx1ZSwgdmFsdWUpID0+IHtcbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgY29uc3QgbWlkZGxlID0gKGxvdyArIGhpZ2gpIC8gMiB8IDA7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlKG1pZGRsZSk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IHZhbHVlKSB7XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gdmFsdWUpIHtcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgfVxuICBpZiAobG93ID4gMCkge1xuICAgIHJldHVybiBsb3cgLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2Uoe1xuICBtZWFzdXJlbWVudHMsXG4gIG91dGVyU2l6ZSxcbiAgc2Nyb2xsT2Zmc2V0XG59KSB7XG4gIGNvbnN0IGNvdW50ID0gbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGdldE9mZnNldCA9IChpbmRleCkgPT4gbWVhc3VyZW1lbnRzW2luZGV4XS5zdGFydDtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKDAsIGNvdW50LCBnZXRPZmZzZXQsIHNjcm9sbE9mZnNldCk7XG4gIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIHdoaWxlIChlbmRJbmRleCA8IGNvdW50ICYmIG1lYXN1cmVtZW50c1tlbmRJbmRleF0uZW5kIDwgc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgZW5kSW5kZXgrKztcbiAgfVxuICByZXR1cm4geyBzdGFydEluZGV4LCBlbmRJbmRleCB9O1xufVxuZXhwb3J0IHtcbiAgVmlydHVhbGl6ZXIsXG4gIGFwcHJveEVxdWFsLFxuICBkZWJvdW5jZSxcbiAgZGVmYXVsdEtleUV4dHJhY3RvcixcbiAgZGVmYXVsdFJhbmdlRXh0cmFjdG9yLFxuICBlbGVtZW50U2Nyb2xsLFxuICBtZWFzdXJlRWxlbWVudCxcbiAgbWVtbyxcbiAgbm90VW5kZWZpbmVkLFxuICBvYnNlcnZlRWxlbWVudE9mZnNldCxcbiAgb2JzZXJ2ZUVsZW1lbnRSZWN0LFxuICBvYnNlcnZlV2luZG93T2Zmc2V0LFxuICBvYnNlcnZlV2luZG93UmVjdCxcbiAgd2luZG93U2Nyb2xsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiZGVib3VuY2UiLCJtZW1vIiwibm90VW5kZWZpbmVkIiwiYXBwcm94RXF1YWwiLCJkZWZhdWx0S2V5RXh0cmFjdG9yIiwiaW5kZXgiLCJkZWZhdWx0UmFuZ2VFeHRyYWN0b3IiLCJyYW5nZSIsInN0YXJ0IiwiTWF0aCIsIm1heCIsInN0YXJ0SW5kZXgiLCJvdmVyc2NhbiIsImVuZCIsIm1pbiIsImVuZEluZGV4IiwiY291bnQiLCJhcnIiLCJpIiwicHVzaCIsIm9ic2VydmVFbGVtZW50UmVjdCIsImluc3RhbmNlIiwiY2IiLCJlbGVtZW50Iiwic2Nyb2xsRWxlbWVudCIsInRhcmdldFdpbmRvdyIsImhhbmRsZXIiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZW50cnkiLCJib3JkZXJCb3hTaXplIiwiYm94IiwiaW5saW5lU2l6ZSIsImJsb2NrU2l6ZSIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJhZGRFdmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmUiLCJvYnNlcnZlV2luZG93UmVjdCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3VwcG9ydHNTY3JvbGxlbmQiLCJ3aW5kb3ciLCJvYnNlcnZlRWxlbWVudE9mZnNldCIsIm9mZnNldCIsImZhbGxiYWNrIiwib3B0aW9ucyIsInVzZVNjcm9sbGVuZEV2ZW50IiwiaXNTY3JvbGxpbmdSZXNldERlbGF5IiwiY3JlYXRlSGFuZGxlciIsImlzU2Nyb2xsaW5nIiwiaG9yaXpvbnRhbCIsImlzUnRsIiwiZW5kSGFuZGxlciIsIm9ic2VydmVXaW5kb3dPZmZzZXQiLCJtZWFzdXJlRWxlbWVudCIsInNpemUiLCJ3aW5kb3dTY3JvbGwiLCJhZGp1c3RtZW50cyIsImJlaGF2aW9yIiwiX2EiLCJfYiIsInRvT2Zmc2V0Iiwic2Nyb2xsVG8iLCJjYWxsIiwiZWxlbWVudFNjcm9sbCIsIlZpcnR1YWxpemVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwidW5zdWJzIiwic2Nyb2xsVG9JbmRleFRpbWVvdXRJZCIsIm1lYXN1cmVtZW50c0NhY2hlIiwiaXRlbVNpemVDYWNoZSIsIk1hcCIsInBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyIsInNjcm9sbFJlY3QiLCJzY3JvbGxPZmZzZXQiLCJzY3JvbGxEaXJlY3Rpb24iLCJzY3JvbGxBZGp1c3RtZW50cyIsImVsZW1lbnRzQ2FjaGUiLCJfcm8iLCJnZXQiLCJmb3JFYWNoIiwiX21lYXN1cmVFbGVtZW50IiwidGFyZ2V0IiwiZGlzY29ubmVjdCIsInNldE9wdGlvbnMiLCJvcHRzMiIsIk9iamVjdCIsImtleSIsInZhbHVlIiwiZGVidWciLCJpbml0aWFsT2Zmc2V0IiwicGFkZGluZ1N0YXJ0IiwicGFkZGluZ0VuZCIsInNjcm9sbFBhZGRpbmdTdGFydCIsInNjcm9sbFBhZGRpbmdFbmQiLCJnZXRJdGVtS2V5IiwicmFuZ2VFeHRyYWN0b3IiLCJvbkNoYW5nZSIsImluaXRpYWxSZWN0Iiwic2Nyb2xsTWFyZ2luIiwiZ2FwIiwiaW5kZXhBdHRyaWJ1dGUiLCJpbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGUiLCJsYW5lcyIsImVuYWJsZWQiLCJub3RpZnkiLCJzeW5jIiwibWF5YmVOb3RpZnkiLCJjYWxjdWxhdGVSYW5nZSIsInByb2Nlc3MiLCJpbml0aWFsRGVwcyIsImNsZWFudXAiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZCIsIl9kaWRNb3VudCIsIl93aWxsVXBkYXRlIiwiZ2V0U2Nyb2xsRWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImNhY2hlZCIsIl9zY3JvbGxUb09mZnNldCIsImdldFNjcm9sbE9mZnNldCIsImdldFNpemUiLCJnZXRGdXJ0aGVzdE1lYXN1cmVtZW50IiwibWVhc3VyZW1lbnRzIiwiZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZCIsImZ1cnRoZXN0TWVhc3VyZW1lbnRzIiwibSIsIm1lYXN1cmVtZW50IiwiaGFzIiwibGFuZSIsInByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCIsInNldCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsImdldE1lYXN1cmVtZW50T3B0aW9ucyIsImdldE1lYXN1cmVtZW50cyIsImNsZWFyIiwibGVuZ3RoIiwiaXRlbSIsInNsaWNlIiwiZnVydGhlc3RNZWFzdXJlbWVudCIsIm1lYXN1cmVkU2l6ZSIsImVzdGltYXRlU2l6ZSIsIm91dGVyU2l6ZSIsImdldEluZGV4ZXMiLCJpbmRleEZyb21FbGVtZW50Iiwibm9kZSIsImF0dHJpYnV0ZU5hbWUiLCJpbmRleFN0ciIsImdldEF0dHJpYnV0ZSIsImNvbnNvbGUiLCJ3YXJuIiwicGFyc2VJbnQiLCJwcmV2Tm9kZSIsImlzQ29ubmVjdGVkIiwicmVzaXplSXRlbSIsIml0ZW1TaXplIiwiZGVsdGEiLCJzaG91bGRBZGp1c3RTY3JvbGxQb3NpdGlvbk9uSXRlbVNpemVDaGFuZ2UiLCJpbmZvIiwiZGVsZXRlIiwiZ2V0VmlydHVhbEl0ZW1zIiwiaW5kZXhlcyIsInZpcnR1YWxJdGVtcyIsImsiLCJsZW4iLCJnZXRWaXJ0dWFsSXRlbUZvck9mZnNldCIsImZpbmROZWFyZXN0QmluYXJ5U2VhcmNoIiwiZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50IiwiYWxpZ24iLCJzY3JvbGxTaXplUHJvcCIsInNjcm9sbFNpemUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsIm1heE9mZnNldCIsImdldE9mZnNldEZvckluZGV4IiwiaXNEeW5hbWljTW9kZSIsImNhbmNlbFNjcm9sbFRvSW5kZXgiLCJjbGVhclRpbWVvdXQiLCJzY3JvbGxUb09mZnNldCIsInNjcm9sbFRvSW5kZXgiLCJpbml0aWFsQWxpZ24iLCJvZmZzZXRBbmRBbGlnbiIsInNldFRpbWVvdXQiLCJlbGVtZW50SW5ET00iLCJsYXRlc3RPZmZzZXQiLCJzY3JvbGxCeSIsImdldFRvdGFsU2l6ZSIsIm1hcCIsInNjcm9sbFRvRm4iLCJtZWFzdXJlIiwibG93IiwiaGlnaCIsImdldEN1cnJlbnRWYWx1ZSIsIm1pZGRsZSIsImN1cnJlbnRWYWx1ZSIsImdldE9mZnNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n    let deps = opts.initialDeps ?? [];\n    let result;\n    return ()=>{\n        var _a, _b, _c, _d;\n        let depTime;\n        if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n        result = fn(...newDeps);\n        if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n            const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n            const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n            const resultFpsPercentage = resultEndTime / 16;\n            const pad = (str, num)=>{\n                str = String(str);\n                while(str.length < num){\n                    str = \" \" + str;\n                }\n                return str;\n            };\n            console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n        }\n        (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n        return result;\n    };\n}\nfunction notUndefined(value, msg) {\n    if (value === void 0) {\n        throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n    } else {\n        return value;\n    }\n}\nconst approxEqual = (a, b)=>Math.abs(a - b) < 1;\nconst debounce = (targetWindow, fn, ms)=>{\n    let timeoutId;\n    return function(...args) {\n        targetWindow.clearTimeout(timeoutId);\n        timeoutId = targetWindow.setTimeout(()=>fn.apply(this, args), ms);\n    };\n};\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsU0FBU0EsS0FBS0MsT0FBTyxFQUFFQyxFQUFFLEVBQUVDLElBQUk7SUFDN0IsSUFBSUMsT0FBT0QsS0FBS0UsV0FBVyxJQUFJLEVBQUU7SUFDakMsSUFBSUM7SUFDSixPQUFPO1FBQ0wsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDaEIsSUFBSUM7UUFDSixJQUFJUixLQUFLUyxHQUFHLElBQUssRUFBQ0wsS0FBS0osS0FBS1UsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJTixHQUFHTyxJQUFJLENBQUNYLEtBQUksR0FBSVEsVUFBVUksS0FBS0MsR0FBRztRQUN4RixNQUFNQyxVQUFVaEI7UUFDaEIsTUFBTWlCLGNBQWNELFFBQVFFLE1BQU0sS0FBS2YsS0FBS2UsTUFBTSxJQUFJRixRQUFRRyxJQUFJLENBQUMsQ0FBQ0MsS0FBS0MsUUFBVWxCLElBQUksQ0FBQ2tCLE1BQU0sS0FBS0Q7UUFDbkcsSUFBSSxDQUFDSCxhQUFhO1lBQ2hCLE9BQU9aO1FBQ1Q7UUFDQUYsT0FBT2E7UUFDUCxJQUFJTTtRQUNKLElBQUlwQixLQUFLUyxHQUFHLElBQUssRUFBQ0osS0FBS0wsS0FBS1UsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJTCxHQUFHTSxJQUFJLENBQUNYLEtBQUksR0FBSW9CLGFBQWFSLEtBQUtDLEdBQUc7UUFDM0ZWLFNBQVNKLE1BQU1lO1FBQ2YsSUFBSWQsS0FBS1MsR0FBRyxJQUFLLEVBQUNILEtBQUtOLEtBQUtVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSUosR0FBR0ssSUFBSSxDQUFDWCxLQUFJLEdBQUk7WUFDcEUsTUFBTXFCLGFBQWFDLEtBQUtDLEtBQUssQ0FBQyxDQUFDWCxLQUFLQyxHQUFHLEtBQUtMLE9BQU0sSUFBSyxPQUFPO1lBQzlELE1BQU1nQixnQkFBZ0JGLEtBQUtDLEtBQUssQ0FBQyxDQUFDWCxLQUFLQyxHQUFHLEtBQUtPLFVBQVMsSUFBSyxPQUFPO1lBQ3BFLE1BQU1LLHNCQUFzQkQsZ0JBQWdCO1lBQzVDLE1BQU1FLE1BQU0sQ0FBQ0MsS0FBS0M7Z0JBQ2hCRCxNQUFNRSxPQUFPRjtnQkFDYixNQUFPQSxJQUFJWCxNQUFNLEdBQUdZLElBQUs7b0JBQ3ZCRCxNQUFNLE1BQU1BO2dCQUNkO2dCQUNBLE9BQU9BO1lBQ1Q7WUFDQUcsUUFBUUMsSUFBSSxDQUNWLENBQUMsSUFBSSxFQUFFTCxJQUFJRixlQUFlLEdBQUcsRUFBRSxFQUFFRSxJQUFJTCxZQUFZLEdBQUcsR0FBRyxDQUFDLEVBQ3hELENBQUM7Ozt1QkFHYyxFQUFFQyxLQUFLVSxHQUFHLENBQ3ZCLEdBQ0FWLEtBQUtXLEdBQUcsQ0FBQyxNQUFNLE1BQU1SLHFCQUFxQixNQUMxQyxjQUFjLENBQUMsRUFDakJ6QixRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLUyxHQUFHO1FBRXBDO1FBQ0NGLENBQUFBLEtBQUtQLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtrQyxRQUFRLEtBQUssT0FBTyxLQUFLLElBQUkzQixHQUFHSSxJQUFJLENBQUNYLE1BQU1HO1FBQzlFLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLFNBQVNnQyxhQUFhQyxLQUFLLEVBQUVDLEdBQUc7SUFDOUIsSUFBSUQsVUFBVSxLQUFLLEdBQUc7UUFDcEIsTUFBTSxJQUFJRSxNQUFNLENBQUMsb0JBQW9CLEVBQUVELE1BQU0sQ0FBQyxFQUFFLEVBQUVBLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNoRSxPQUFPO1FBQ0wsT0FBT0Q7SUFDVDtBQUNGO0FBQ0EsTUFBTUcsY0FBYyxDQUFDQyxHQUFHQyxJQUFNbkIsS0FBS29CLEdBQUcsQ0FBQ0YsSUFBSUMsS0FBSztBQUNoRCxNQUFNRSxXQUFXLENBQUNDLGNBQWM3QyxJQUFJOEM7SUFDbEMsSUFBSUM7SUFDSixPQUFPLFNBQVMsR0FBR0MsSUFBSTtRQUNyQkgsYUFBYUksWUFBWSxDQUFDRjtRQUMxQkEsWUFBWUYsYUFBYUssVUFBVSxDQUFDLElBQU1sRCxHQUFHbUQsS0FBSyxDQUFDLElBQUksRUFBRUgsT0FBT0Y7SUFDbEU7QUFDRjtBQU1FLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktaW50ZXJ2aWV3ZXIvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcz80OTcyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcbiAgbGV0IGRlcHMgPSBvcHRzLmluaXRpYWxEZXBzID8/IFtdO1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBsZXQgZGVwVGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYSA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMpKSkgZGVwVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbmV3RGVwcyA9IGdldERlcHMoKTtcbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoKGRlcCwgaW5kZXgpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIGxldCByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9iID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0cykpKSByZXN1bHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXN1bHQgPSBmbiguLi5uZXdEZXBzKTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYyA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKG9wdHMpKSkge1xuICAgICAgY29uc3QgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICBjb25zdCByZXN1bHRFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHJlc3VsdFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICBjb25zdCBwYWQgPSAoc3RyLCBudW0pID0+IHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgc3RyID0gXCIgXCIgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH07XG4gICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgIGAlY+KPsSAke3BhZChyZXN1bHRFbmRUaW1lLCA1KX0gLyR7cGFkKGRlcEVuZFRpbWUsIDUpfSBtc2AsXG4gICAgICAgIGBcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogLjZyZW07XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGNvbG9yOiBoc2woJHtNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKDEyMCAtIDEyMCAqIHJlc3VsdEZwc1BlcmNlbnRhZ2UsIDEyMClcbiAgICAgICAgKX1kZWcgMTAwJSAzMSUpO2AsXG4gICAgICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMua2V5XG4gICAgICApO1xuICAgIH1cbiAgICAoX2QgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChvcHRzLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBub3RVbmRlZmluZWQodmFsdWUsIG1zZykge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB1bmRlZmluZWQke21zZyA/IGA6ICR7bXNnfWAgOiBcIlwifWApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgYXBwcm94RXF1YWwgPSAoYSwgYikgPT4gTWF0aC5hYnMoYSAtIGIpIDwgMTtcbmNvbnN0IGRlYm91bmNlID0gKHRhcmdldFdpbmRvdywgZm4sIG1zKSA9PiB7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgdGFyZ2V0V2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIHRpbWVvdXRJZCA9IHRhcmdldFdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IGZuLmFwcGx5KHRoaXMsIGFyZ3MpLCBtcyk7XG4gIH07XG59O1xuZXhwb3J0IHtcbiAgYXBwcm94RXF1YWwsXG4gIGRlYm91bmNlLFxuICBtZW1vLFxuICBub3RVbmRlZmluZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJtZW1vIiwiZ2V0RGVwcyIsImZuIiwib3B0cyIsImRlcHMiLCJpbml0aWFsRGVwcyIsInJlc3VsdCIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiZGVwVGltZSIsImtleSIsImRlYnVnIiwiY2FsbCIsIkRhdGUiLCJub3ciLCJuZXdEZXBzIiwiZGVwc0NoYW5nZWQiLCJsZW5ndGgiLCJzb21lIiwiZGVwIiwiaW5kZXgiLCJyZXN1bHRUaW1lIiwiZGVwRW5kVGltZSIsIk1hdGgiLCJyb3VuZCIsInJlc3VsdEVuZFRpbWUiLCJyZXN1bHRGcHNQZXJjZW50YWdlIiwicGFkIiwic3RyIiwibnVtIiwiU3RyaW5nIiwiY29uc29sZSIsImluZm8iLCJtYXgiLCJtaW4iLCJvbkNoYW5nZSIsIm5vdFVuZGVmaW5lZCIsInZhbHVlIiwibXNnIiwiRXJyb3IiLCJhcHByb3hFcXVhbCIsImEiLCJiIiwiYWJzIiwiZGVib3VuY2UiLCJ0YXJnZXRXaW5kb3ciLCJtcyIsInRpbWVvdXRJZCIsImFyZ3MiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\n");

/***/ })

};
;