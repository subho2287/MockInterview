"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parse-entities";
exports.ids = ["vendor-chunks/parse-entities"];
exports.modules = {

/***/ "(ssr)/./node_modules/parse-entities/decode-entity.js":
/*!******************************************************!*\
  !*** ./node_modules/parse-entities/decode-entity.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar characterEntities = __webpack_require__(/*! character-entities */ \"(ssr)/./node_modules/character-entities/index.json\");\nmodule.exports = decodeEntity;\nvar own = {}.hasOwnProperty;\nfunction decodeEntity(characters) {\n    return own.call(characterEntities, characters) ? characterEntities[characters] : false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGFyc2UtZW50aXRpZXMvZGVjb2RlLWVudGl0eS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLG9CQUFvQkMsbUJBQU9BLENBQUM7QUFFaENDLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsTUFBTSxDQUFDLEVBQUVDLGNBQWM7QUFFM0IsU0FBU0YsYUFBYUcsVUFBVTtJQUM5QixPQUFPRixJQUFJRyxJQUFJLENBQUNSLG1CQUFtQk8sY0FDL0JQLGlCQUFpQixDQUFDTyxXQUFXLEdBQzdCO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1pbnRlcnZpZXdlci8uL25vZGVfbW9kdWxlcy9wYXJzZS1lbnRpdGllcy9kZWNvZGUtZW50aXR5LmpzP2MyNzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBjaGFyYWN0ZXJFbnRpdGllcyA9IHJlcXVpcmUoJ2NoYXJhY3Rlci1lbnRpdGllcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlRW50aXR5XG5cbnZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG5mdW5jdGlvbiBkZWNvZGVFbnRpdHkoY2hhcmFjdGVycykge1xuICByZXR1cm4gb3duLmNhbGwoY2hhcmFjdGVyRW50aXRpZXMsIGNoYXJhY3RlcnMpXG4gICAgPyBjaGFyYWN0ZXJFbnRpdGllc1tjaGFyYWN0ZXJzXVxuICAgIDogZmFsc2Vcbn1cbiJdLCJuYW1lcyI6WyJjaGFyYWN0ZXJFbnRpdGllcyIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVjb2RlRW50aXR5Iiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJjaGFyYWN0ZXJzIiwiY2FsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/parse-entities/decode-entity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/parse-entities/index.js":
/*!**********************************************!*\
  !*** ./node_modules/parse-entities/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar legacy = __webpack_require__(/*! character-entities-legacy */ \"(ssr)/./node_modules/character-entities-legacy/index.json\");\nvar invalid = __webpack_require__(/*! character-reference-invalid */ \"(ssr)/./node_modules/character-reference-invalid/index.json\");\nvar decimal = __webpack_require__(/*! is-decimal */ \"(ssr)/./node_modules/is-decimal/index.js\");\nvar hexadecimal = __webpack_require__(/*! is-hexadecimal */ \"(ssr)/./node_modules/is-hexadecimal/index.js\");\nvar alphanumerical = __webpack_require__(/*! is-alphanumerical */ \"(ssr)/./node_modules/is-alphanumerical/index.js\");\nvar decodeEntity = __webpack_require__(/*! ./decode-entity */ \"(ssr)/./node_modules/parse-entities/decode-entity.js\");\nmodule.exports = parseEntities;\nvar own = {}.hasOwnProperty;\nvar fromCharCode = String.fromCharCode;\nvar noop = Function.prototype;\n// Default settings.\nvar defaults = {\n    warning: null,\n    reference: null,\n    text: null,\n    warningContext: null,\n    referenceContext: null,\n    textContext: null,\n    position: {},\n    additional: null,\n    attribute: false,\n    nonTerminated: true\n};\n// Characters.\nvar tab = 9 // '\\t'\n;\nvar lineFeed = 10 // '\\n'\n;\nvar formFeed = 12 // '\\f'\n;\nvar space = 32 // ' '\n;\nvar ampersand = 38 // '&'\n;\nvar semicolon = 59 // ';'\n;\nvar lessThan = 60 // '<'\n;\nvar equalsTo = 61 // '='\n;\nvar numberSign = 35 // '#'\n;\nvar uppercaseX = 88 // 'X'\n;\nvar lowercaseX = 120 // 'x'\n;\nvar replacementCharacter = 65533 // '�'\n;\n// Reference types.\nvar name = \"named\";\nvar hexa = \"hexadecimal\";\nvar deci = \"decimal\";\n// Map of bases.\nvar bases = {};\nbases[hexa] = 16;\nbases[deci] = 10;\n// Map of types to tests.\n// Each type of character reference accepts different characters.\n// This test is used to detect whether a reference has ended (as the semicolon\n// is not strictly needed).\nvar tests = {};\ntests[name] = alphanumerical;\ntests[deci] = decimal;\ntests[hexa] = hexadecimal;\n// Warning types.\nvar namedNotTerminated = 1;\nvar numericNotTerminated = 2;\nvar namedEmpty = 3;\nvar numericEmpty = 4;\nvar namedUnknown = 5;\nvar numericDisallowed = 6;\nvar numericProhibited = 7;\n// Warning messages.\nvar messages = {};\nmessages[namedNotTerminated] = \"Named character references must be terminated by a semicolon\";\nmessages[numericNotTerminated] = \"Numeric character references must be terminated by a semicolon\";\nmessages[namedEmpty] = \"Named character references cannot be empty\";\nmessages[numericEmpty] = \"Numeric character references cannot be empty\";\nmessages[namedUnknown] = \"Named character references must be known\";\nmessages[numericDisallowed] = \"Numeric character references cannot be disallowed\";\nmessages[numericProhibited] = \"Numeric character references cannot be outside the permissible Unicode range\";\n// Wrap to ensure clean parameters are given to `parse`.\nfunction parseEntities(value, options) {\n    var settings = {};\n    var option;\n    var key;\n    if (!options) {\n        options = {};\n    }\n    for(key in defaults){\n        option = options[key];\n        settings[key] = option === null || option === undefined ? defaults[key] : option;\n    }\n    if (settings.position.indent || settings.position.start) {\n        settings.indent = settings.position.indent || [];\n        settings.position = settings.position.start;\n    }\n    return parse(value, settings);\n}\n// Parse entities.\n// eslint-disable-next-line complexity\nfunction parse(value, settings) {\n    var additional = settings.additional;\n    var nonTerminated = settings.nonTerminated;\n    var handleText = settings.text;\n    var handleReference = settings.reference;\n    var handleWarning = settings.warning;\n    var textContext = settings.textContext;\n    var referenceContext = settings.referenceContext;\n    var warningContext = settings.warningContext;\n    var pos = settings.position;\n    var indent = settings.indent || [];\n    var length = value.length;\n    var index = 0;\n    var lines = -1;\n    var column = pos.column || 1;\n    var line = pos.line || 1;\n    var queue = \"\";\n    var result = [];\n    var entityCharacters;\n    var namedEntity;\n    var terminated;\n    var characters;\n    var character;\n    var reference;\n    var following;\n    var warning;\n    var reason;\n    var output;\n    var entity;\n    var begin;\n    var start;\n    var type;\n    var test;\n    var prev;\n    var next;\n    var diff;\n    var end;\n    if (typeof additional === \"string\") {\n        additional = additional.charCodeAt(0);\n    }\n    // Cache the current point.\n    prev = now();\n    // Wrap `handleWarning`.\n    warning = handleWarning ? parseError : noop;\n    // Ensure the algorithm walks over the first character and the end\n    // (inclusive).\n    index--;\n    length++;\n    while(++index < length){\n        // If the previous character was a newline.\n        if (character === lineFeed) {\n            column = indent[lines] || 1;\n        }\n        character = value.charCodeAt(index);\n        if (character === ampersand) {\n            following = value.charCodeAt(index + 1);\n            // The behaviour depends on the identity of the next character.\n            if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {\n                // Not a character reference.\n                // No characters are consumed, and nothing is returned.\n                // This is not an error, either.\n                queue += fromCharCode(character);\n                column++;\n                continue;\n            }\n            start = index + 1;\n            begin = start;\n            end = start;\n            if (following === numberSign) {\n                // Numerical entity.\n                end = ++begin;\n                // The behaviour further depends on the next character.\n                following = value.charCodeAt(end);\n                if (following === uppercaseX || following === lowercaseX) {\n                    // ASCII hex digits.\n                    type = hexa;\n                    end = ++begin;\n                } else {\n                    // ASCII digits.\n                    type = deci;\n                }\n            } else {\n                // Named entity.\n                type = name;\n            }\n            entityCharacters = \"\";\n            entity = \"\";\n            characters = \"\";\n            test = tests[type];\n            end--;\n            while(++end < length){\n                following = value.charCodeAt(end);\n                if (!test(following)) {\n                    break;\n                }\n                characters += fromCharCode(following);\n                // Check if we can match a legacy named reference.\n                // If so, we cache that as the last viable named reference.\n                // This ensures we do not need to walk backwards later.\n                if (type === name && own.call(legacy, characters)) {\n                    entityCharacters = characters;\n                    entity = legacy[characters];\n                }\n            }\n            terminated = value.charCodeAt(end) === semicolon;\n            if (terminated) {\n                end++;\n                namedEntity = type === name ? decodeEntity(characters) : false;\n                if (namedEntity) {\n                    entityCharacters = characters;\n                    entity = namedEntity;\n                }\n            }\n            diff = 1 + end - start;\n            if (!terminated && !nonTerminated) {\n            // Empty.\n            } else if (!characters) {\n                // An empty (possible) entity is valid, unless it’s numeric (thus an\n                // ampersand followed by an octothorp).\n                if (type !== name) {\n                    warning(numericEmpty, diff);\n                }\n            } else if (type === name) {\n                // An ampersand followed by anything unknown, and not terminated, is\n                // invalid.\n                if (terminated && !entity) {\n                    warning(namedUnknown, 1);\n                } else {\n                    // If theres something after an entity name which is not known, cap\n                    // the reference.\n                    if (entityCharacters !== characters) {\n                        end = begin + entityCharacters.length;\n                        diff = 1 + end - begin;\n                        terminated = false;\n                    }\n                    // If the reference is not terminated, warn.\n                    if (!terminated) {\n                        reason = entityCharacters ? namedNotTerminated : namedEmpty;\n                        if (settings.attribute) {\n                            following = value.charCodeAt(end);\n                            if (following === equalsTo) {\n                                warning(reason, diff);\n                                entity = null;\n                            } else if (alphanumerical(following)) {\n                                entity = null;\n                            } else {\n                                warning(reason, diff);\n                            }\n                        } else {\n                            warning(reason, diff);\n                        }\n                    }\n                }\n                reference = entity;\n            } else {\n                if (!terminated) {\n                    // All non-terminated numeric entities are not rendered, and trigger a\n                    // warning.\n                    warning(numericNotTerminated, diff);\n                }\n                // When terminated and number, parse as either hexadecimal or decimal.\n                reference = parseInt(characters, bases[type]);\n                // Trigger a warning when the parsed number is prohibited, and replace\n                // with replacement character.\n                if (prohibited(reference)) {\n                    warning(numericProhibited, diff);\n                    reference = fromCharCode(replacementCharacter);\n                } else if (reference in invalid) {\n                    // Trigger a warning when the parsed number is disallowed, and replace\n                    // by an alternative.\n                    warning(numericDisallowed, diff);\n                    reference = invalid[reference];\n                } else {\n                    // Parse the number.\n                    output = \"\";\n                    // Trigger a warning when the parsed number should not be used.\n                    if (disallowed(reference)) {\n                        warning(numericDisallowed, diff);\n                    }\n                    // Stringify the number.\n                    if (reference > 0xffff) {\n                        reference -= 0x10000;\n                        output += fromCharCode(reference >>> (10 & 0x3ff) | 0xd800);\n                        reference = 0xdc00 | reference & 0x3ff;\n                    }\n                    reference = output + fromCharCode(reference);\n                }\n            }\n            // Found it!\n            // First eat the queued characters as normal text, then eat an entity.\n            if (reference) {\n                flush();\n                prev = now();\n                index = end - 1;\n                column += end - start + 1;\n                result.push(reference);\n                next = now();\n                next.offset++;\n                if (handleReference) {\n                    handleReference.call(referenceContext, reference, {\n                        start: prev,\n                        end: next\n                    }, value.slice(start - 1, end));\n                }\n                prev = next;\n            } else {\n                // If we could not find a reference, queue the checked characters (as\n                // normal characters), and move the pointer to their end.\n                // This is possible because we can be certain neither newlines nor\n                // ampersands are included.\n                characters = value.slice(start - 1, end);\n                queue += characters;\n                column += characters.length;\n                index = end - 1;\n            }\n        } else {\n            // Handle anything other than an ampersand, including newlines and EOF.\n            if (character === 10 // Line feed\n            ) {\n                line++;\n                lines++;\n                column = 0;\n            }\n            if (character === character) {\n                queue += fromCharCode(character);\n                column++;\n            } else {\n                flush();\n            }\n        }\n    }\n    // Return the reduced nodes.\n    return result.join(\"\");\n    // Get current position.\n    function now() {\n        return {\n            line: line,\n            column: column,\n            offset: index + (pos.offset || 0)\n        };\n    }\n    // “Throw” a parse-error: a warning.\n    function parseError(code, offset) {\n        var position = now();\n        position.column += offset;\n        position.offset += offset;\n        handleWarning.call(warningContext, messages[code], position, code);\n    }\n    // Flush `queue` (normal text).\n    // Macro invoked before each entity and at the end of `value`.\n    // Does nothing when `queue` is empty.\n    function flush() {\n        if (queue) {\n            result.push(queue);\n            if (handleText) {\n                handleText.call(textContext, queue, {\n                    start: prev,\n                    end: now()\n                });\n            }\n            queue = \"\";\n        }\n    }\n}\n// Check if `character` is outside the permissible unicode range.\nfunction prohibited(code) {\n    return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n// Check if `character` is disallowed.\nfunction disallowed(code) {\n    return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGFyc2UtZW50aXRpZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN0QixJQUFJRSxVQUFVRixtQkFBT0EsQ0FBQztBQUN0QixJQUFJRyxjQUFjSCxtQkFBT0EsQ0FBQztBQUMxQixJQUFJSSxpQkFBaUJKLG1CQUFPQSxDQUFDO0FBQzdCLElBQUlLLGVBQWVMLG1CQUFPQSxDQUFDO0FBRTNCTSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE1BQU0sQ0FBQyxFQUFFQyxjQUFjO0FBQzNCLElBQUlDLGVBQWVDLE9BQU9ELFlBQVk7QUFDdEMsSUFBSUUsT0FBT0MsU0FBU0MsU0FBUztBQUU3QixvQkFBb0I7QUFDcEIsSUFBSUMsV0FBVztJQUNiQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsYUFBYTtJQUNiQyxVQUFVLENBQUM7SUFDWEMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLGVBQWU7QUFDakI7QUFFQSxjQUFjO0FBQ2QsSUFBSUMsTUFBTSxFQUFFLE9BQU87O0FBQ25CLElBQUlDLFdBQVcsR0FBRyxPQUFPOztBQUN6QixJQUFJQyxXQUFXLEdBQUcsT0FBTzs7QUFDekIsSUFBSUMsUUFBUSxHQUFHLE1BQU07O0FBQ3JCLElBQUlDLFlBQVksR0FBRyxNQUFNOztBQUN6QixJQUFJQyxZQUFZLEdBQUcsTUFBTTs7QUFDekIsSUFBSUMsV0FBVyxHQUFHLE1BQU07O0FBQ3hCLElBQUlDLFdBQVcsR0FBRyxNQUFNOztBQUN4QixJQUFJQyxhQUFhLEdBQUcsTUFBTTs7QUFDMUIsSUFBSUMsYUFBYSxHQUFHLE1BQU07O0FBQzFCLElBQUlDLGFBQWEsSUFBSSxNQUFNOztBQUMzQixJQUFJQyx1QkFBdUIsTUFBTSxNQUFNOztBQUV2QyxtQkFBbUI7QUFD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azovL2FpLWludGVydmlld2VyLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWVudGl0aWVzL2luZGV4LmpzP2Y0MjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBsZWdhY3kgPSByZXF1aXJlKCdjaGFyYWN0ZXItZW50aXRpZXMtbGVnYWN5JylcbnZhciBpbnZhbGlkID0gcmVxdWlyZSgnY2hhcmFjdGVyLXJlZmVyZW5jZS1pbnZhbGlkJylcbnZhciBkZWNpbWFsID0gcmVxdWlyZSgnaXMtZGVjaW1hbCcpXG52YXIgaGV4YWRlY2ltYWwgPSByZXF1aXJlKCdpcy1oZXhhZGVjaW1hbCcpXG52YXIgYWxwaGFudW1lcmljYWwgPSByZXF1aXJlKCdpcy1hbHBoYW51bWVyaWNhbCcpXG52YXIgZGVjb2RlRW50aXR5ID0gcmVxdWlyZSgnLi9kZWNvZGUtZW50aXR5JylcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUVudGl0aWVzXG5cbnZhciBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbnZhciBub29wID0gRnVuY3Rpb24ucHJvdG90eXBlXG5cbi8vIERlZmF1bHQgc2V0dGluZ3MuXG52YXIgZGVmYXVsdHMgPSB7XG4gIHdhcm5pbmc6IG51bGwsXG4gIHJlZmVyZW5jZTogbnVsbCxcbiAgdGV4dDogbnVsbCxcbiAgd2FybmluZ0NvbnRleHQ6IG51bGwsXG4gIHJlZmVyZW5jZUNvbnRleHQ6IG51bGwsXG4gIHRleHRDb250ZXh0OiBudWxsLFxuICBwb3NpdGlvbjoge30sXG4gIGFkZGl0aW9uYWw6IG51bGwsXG4gIGF0dHJpYnV0ZTogZmFsc2UsXG4gIG5vblRlcm1pbmF0ZWQ6IHRydWVcbn1cblxuLy8gQ2hhcmFjdGVycy5cbnZhciB0YWIgPSA5IC8vICdcXHQnXG52YXIgbGluZUZlZWQgPSAxMCAvLyAnXFxuJ1xudmFyIGZvcm1GZWVkID0gMTIgLy8gJ1xcZidcbnZhciBzcGFjZSA9IDMyIC8vICcgJ1xudmFyIGFtcGVyc2FuZCA9IDM4IC8vICcmJ1xudmFyIHNlbWljb2xvbiA9IDU5IC8vICc7J1xudmFyIGxlc3NUaGFuID0gNjAgLy8gJzwnXG52YXIgZXF1YWxzVG8gPSA2MSAvLyAnPSdcbnZhciBudW1iZXJTaWduID0gMzUgLy8gJyMnXG52YXIgdXBwZXJjYXNlWCA9IDg4IC8vICdYJ1xudmFyIGxvd2VyY2FzZVggPSAxMjAgLy8gJ3gnXG52YXIgcmVwbGFjZW1lbnRDaGFyYWN0ZXIgPSA2NTUzMyAvLyAn77+9J1xuXG4vLyBSZWZlcmVuY2UgdHlwZXMuXG52YXIgbmFtZSA9ICduYW1lZCdcbnZhciBoZXhhID0gJ2hleGFkZWNpbWFsJ1xudmFyIGRlY2kgPSAnZGVjaW1hbCdcblxuLy8gTWFwIG9mIGJhc2VzLlxudmFyIGJhc2VzID0ge31cblxuYmFzZXNbaGV4YV0gPSAxNlxuYmFzZXNbZGVjaV0gPSAxMFxuXG4vLyBNYXAgb2YgdHlwZXMgdG8gdGVzdHMuXG4vLyBFYWNoIHR5cGUgb2YgY2hhcmFjdGVyIHJlZmVyZW5jZSBhY2NlcHRzIGRpZmZlcmVudCBjaGFyYWN0ZXJzLlxuLy8gVGhpcyB0ZXN0IGlzIHVzZWQgdG8gZGV0ZWN0IHdoZXRoZXIgYSByZWZlcmVuY2UgaGFzIGVuZGVkIChhcyB0aGUgc2VtaWNvbG9uXG4vLyBpcyBub3Qgc3RyaWN0bHkgbmVlZGVkKS5cbnZhciB0ZXN0cyA9IHt9XG5cbnRlc3RzW25hbWVdID0gYWxwaGFudW1lcmljYWxcbnRlc3RzW2RlY2ldID0gZGVjaW1hbFxudGVzdHNbaGV4YV0gPSBoZXhhZGVjaW1hbFxuXG4vLyBXYXJuaW5nIHR5cGVzLlxudmFyIG5hbWVkTm90VGVybWluYXRlZCA9IDFcbnZhciBudW1lcmljTm90VGVybWluYXRlZCA9IDJcbnZhciBuYW1lZEVtcHR5ID0gM1xudmFyIG51bWVyaWNFbXB0eSA9IDRcbnZhciBuYW1lZFVua25vd24gPSA1XG52YXIgbnVtZXJpY0Rpc2FsbG93ZWQgPSA2XG52YXIgbnVtZXJpY1Byb2hpYml0ZWQgPSA3XG5cbi8vIFdhcm5pbmcgbWVzc2FnZXMuXG52YXIgbWVzc2FnZXMgPSB7fVxuXG5tZXNzYWdlc1tuYW1lZE5vdFRlcm1pbmF0ZWRdID1cbiAgJ05hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIG11c3QgYmUgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbidcbm1lc3NhZ2VzW251bWVyaWNOb3RUZXJtaW5hdGVkXSA9XG4gICdOdW1lcmljIGNoYXJhY3RlciByZWZlcmVuY2VzIG11c3QgYmUgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbidcbm1lc3NhZ2VzW25hbWVkRW1wdHldID0gJ05hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIGNhbm5vdCBiZSBlbXB0eSdcbm1lc3NhZ2VzW251bWVyaWNFbXB0eV0gPSAnTnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBjYW5ub3QgYmUgZW1wdHknXG5tZXNzYWdlc1tuYW1lZFVua25vd25dID0gJ05hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIG11c3QgYmUga25vd24nXG5tZXNzYWdlc1tudW1lcmljRGlzYWxsb3dlZF0gPVxuICAnTnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBjYW5ub3QgYmUgZGlzYWxsb3dlZCdcbm1lc3NhZ2VzW251bWVyaWNQcm9oaWJpdGVkXSA9XG4gICdOdW1lcmljIGNoYXJhY3RlciByZWZlcmVuY2VzIGNhbm5vdCBiZSBvdXRzaWRlIHRoZSBwZXJtaXNzaWJsZSBVbmljb2RlIHJhbmdlJ1xuXG4vLyBXcmFwIHRvIGVuc3VyZSBjbGVhbiBwYXJhbWV0ZXJzIGFyZSBnaXZlbiB0byBgcGFyc2VgLlxuZnVuY3Rpb24gcGFyc2VFbnRpdGllcyh2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgc2V0dGluZ3MgPSB7fVxuICB2YXIgb3B0aW9uXG4gIHZhciBrZXlcblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGZvciAoa2V5IGluIGRlZmF1bHRzKSB7XG4gICAgb3B0aW9uID0gb3B0aW9uc1trZXldXG4gICAgc2V0dGluZ3Nba2V5XSA9XG4gICAgICBvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB1bmRlZmluZWQgPyBkZWZhdWx0c1trZXldIDogb3B0aW9uXG4gIH1cblxuICBpZiAoc2V0dGluZ3MucG9zaXRpb24uaW5kZW50IHx8IHNldHRpbmdzLnBvc2l0aW9uLnN0YXJ0KSB7XG4gICAgc2V0dGluZ3MuaW5kZW50ID0gc2V0dGluZ3MucG9zaXRpb24uaW5kZW50IHx8IFtdXG4gICAgc2V0dGluZ3MucG9zaXRpb24gPSBzZXR0aW5ncy5wb3NpdGlvbi5zdGFydFxuICB9XG5cbiAgcmV0dXJuIHBhcnNlKHZhbHVlLCBzZXR0aW5ncylcbn1cblxuLy8gUGFyc2UgZW50aXRpZXMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcGFyc2UodmFsdWUsIHNldHRpbmdzKSB7XG4gIHZhciBhZGRpdGlvbmFsID0gc2V0dGluZ3MuYWRkaXRpb25hbFxuICB2YXIgbm9uVGVybWluYXRlZCA9IHNldHRpbmdzLm5vblRlcm1pbmF0ZWRcbiAgdmFyIGhhbmRsZVRleHQgPSBzZXR0aW5ncy50ZXh0XG4gIHZhciBoYW5kbGVSZWZlcmVuY2UgPSBzZXR0aW5ncy5yZWZlcmVuY2VcbiAgdmFyIGhhbmRsZVdhcm5pbmcgPSBzZXR0aW5ncy53YXJuaW5nXG4gIHZhciB0ZXh0Q29udGV4dCA9IHNldHRpbmdzLnRleHRDb250ZXh0XG4gIHZhciByZWZlcmVuY2VDb250ZXh0ID0gc2V0dGluZ3MucmVmZXJlbmNlQ29udGV4dFxuICB2YXIgd2FybmluZ0NvbnRleHQgPSBzZXR0aW5ncy53YXJuaW5nQ29udGV4dFxuICB2YXIgcG9zID0gc2V0dGluZ3MucG9zaXRpb25cbiAgdmFyIGluZGVudCA9IHNldHRpbmdzLmluZGVudCB8fCBbXVxuICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIGxpbmVzID0gLTFcbiAgdmFyIGNvbHVtbiA9IHBvcy5jb2x1bW4gfHwgMVxuICB2YXIgbGluZSA9IHBvcy5saW5lIHx8IDFcbiAgdmFyIHF1ZXVlID0gJydcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIHZhciBlbnRpdHlDaGFyYWN0ZXJzXG4gIHZhciBuYW1lZEVudGl0eVxuICB2YXIgdGVybWluYXRlZFxuICB2YXIgY2hhcmFjdGVyc1xuICB2YXIgY2hhcmFjdGVyXG4gIHZhciByZWZlcmVuY2VcbiAgdmFyIGZvbGxvd2luZ1xuICB2YXIgd2FybmluZ1xuICB2YXIgcmVhc29uXG4gIHZhciBvdXRwdXRcbiAgdmFyIGVudGl0eVxuICB2YXIgYmVnaW5cbiAgdmFyIHN0YXJ0XG4gIHZhciB0eXBlXG4gIHZhciB0ZXN0XG4gIHZhciBwcmV2XG4gIHZhciBuZXh0XG4gIHZhciBkaWZmXG4gIHZhciBlbmRcblxuICBpZiAodHlwZW9mIGFkZGl0aW9uYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgYWRkaXRpb25hbCA9IGFkZGl0aW9uYWwuY2hhckNvZGVBdCgwKVxuICB9XG5cbiAgLy8gQ2FjaGUgdGhlIGN1cnJlbnQgcG9pbnQuXG4gIHByZXYgPSBub3coKVxuXG4gIC8vIFdyYXAgYGhhbmRsZVdhcm5pbmdgLlxuICB3YXJuaW5nID0gaGFuZGxlV2FybmluZyA/IHBhcnNlRXJyb3IgOiBub29wXG5cbiAgLy8gRW5zdXJlIHRoZSBhbGdvcml0aG0gd2Fsa3Mgb3ZlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB0aGUgZW5kXG4gIC8vIChpbmNsdXNpdmUpLlxuICBpbmRleC0tXG4gIGxlbmd0aCsrXG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIHdhcyBhIG5ld2xpbmUuXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gbGluZUZlZWQpIHtcbiAgICAgIGNvbHVtbiA9IGluZGVudFtsaW5lc10gfHwgMVxuICAgIH1cblxuICAgIGNoYXJhY3RlciA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpXG5cbiAgICBpZiAoY2hhcmFjdGVyID09PSBhbXBlcnNhbmQpIHtcbiAgICAgIGZvbGxvd2luZyA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXggKyAxKVxuXG4gICAgICAvLyBUaGUgYmVoYXZpb3VyIGRlcGVuZHMgb24gdGhlIGlkZW50aXR5IG9mIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgIGlmIChcbiAgICAgICAgZm9sbG93aW5nID09PSB0YWIgfHxcbiAgICAgICAgZm9sbG93aW5nID09PSBsaW5lRmVlZCB8fFxuICAgICAgICBmb2xsb3dpbmcgPT09IGZvcm1GZWVkIHx8XG4gICAgICAgIGZvbGxvd2luZyA9PT0gc3BhY2UgfHxcbiAgICAgICAgZm9sbG93aW5nID09PSBhbXBlcnNhbmQgfHxcbiAgICAgICAgZm9sbG93aW5nID09PSBsZXNzVGhhbiB8fFxuICAgICAgICBmb2xsb3dpbmcgIT09IGZvbGxvd2luZyB8fFxuICAgICAgICAoYWRkaXRpb25hbCAmJiBmb2xsb3dpbmcgPT09IGFkZGl0aW9uYWwpXG4gICAgICApIHtcbiAgICAgICAgLy8gTm90IGEgY2hhcmFjdGVyIHJlZmVyZW5jZS5cbiAgICAgICAgLy8gTm8gY2hhcmFjdGVycyBhcmUgY29uc3VtZWQsIGFuZCBub3RoaW5nIGlzIHJldHVybmVkLlxuICAgICAgICAvLyBUaGlzIGlzIG5vdCBhbiBlcnJvciwgZWl0aGVyLlxuICAgICAgICBxdWV1ZSArPSBmcm9tQ2hhckNvZGUoY2hhcmFjdGVyKVxuICAgICAgICBjb2x1bW4rK1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXggKyAxXG4gICAgICBiZWdpbiA9IHN0YXJ0XG4gICAgICBlbmQgPSBzdGFydFxuXG4gICAgICBpZiAoZm9sbG93aW5nID09PSBudW1iZXJTaWduKSB7XG4gICAgICAgIC8vIE51bWVyaWNhbCBlbnRpdHkuXG4gICAgICAgIGVuZCA9ICsrYmVnaW5cblxuICAgICAgICAvLyBUaGUgYmVoYXZpb3VyIGZ1cnRoZXIgZGVwZW5kcyBvbiB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICAgIGZvbGxvd2luZyA9IHZhbHVlLmNoYXJDb2RlQXQoZW5kKVxuXG4gICAgICAgIGlmIChmb2xsb3dpbmcgPT09IHVwcGVyY2FzZVggfHwgZm9sbG93aW5nID09PSBsb3dlcmNhc2VYKSB7XG4gICAgICAgICAgLy8gQVNDSUkgaGV4IGRpZ2l0cy5cbiAgICAgICAgICB0eXBlID0gaGV4YVxuICAgICAgICAgIGVuZCA9ICsrYmVnaW5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBU0NJSSBkaWdpdHMuXG4gICAgICAgICAgdHlwZSA9IGRlY2lcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTmFtZWQgZW50aXR5LlxuICAgICAgICB0eXBlID0gbmFtZVxuICAgICAgfVxuXG4gICAgICBlbnRpdHlDaGFyYWN0ZXJzID0gJydcbiAgICAgIGVudGl0eSA9ICcnXG4gICAgICBjaGFyYWN0ZXJzID0gJydcbiAgICAgIHRlc3QgPSB0ZXN0c1t0eXBlXVxuICAgICAgZW5kLS1cblxuICAgICAgd2hpbGUgKCsrZW5kIDwgbGVuZ3RoKSB7XG4gICAgICAgIGZvbGxvd2luZyA9IHZhbHVlLmNoYXJDb2RlQXQoZW5kKVxuXG4gICAgICAgIGlmICghdGVzdChmb2xsb3dpbmcpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJhY3RlcnMgKz0gZnJvbUNoYXJDb2RlKGZvbGxvd2luZylcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gbWF0Y2ggYSBsZWdhY3kgbmFtZWQgcmVmZXJlbmNlLlxuICAgICAgICAvLyBJZiBzbywgd2UgY2FjaGUgdGhhdCBhcyB0aGUgbGFzdCB2aWFibGUgbmFtZWQgcmVmZXJlbmNlLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZG8gbm90IG5lZWQgdG8gd2FsayBiYWNrd2FyZHMgbGF0ZXIuXG4gICAgICAgIGlmICh0eXBlID09PSBuYW1lICYmIG93bi5jYWxsKGxlZ2FjeSwgY2hhcmFjdGVycykpIHtcbiAgICAgICAgICBlbnRpdHlDaGFyYWN0ZXJzID0gY2hhcmFjdGVyc1xuICAgICAgICAgIGVudGl0eSA9IGxlZ2FjeVtjaGFyYWN0ZXJzXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRlcm1pbmF0ZWQgPSB2YWx1ZS5jaGFyQ29kZUF0KGVuZCkgPT09IHNlbWljb2xvblxuXG4gICAgICBpZiAodGVybWluYXRlZCkge1xuICAgICAgICBlbmQrK1xuXG4gICAgICAgIG5hbWVkRW50aXR5ID0gdHlwZSA9PT0gbmFtZSA/IGRlY29kZUVudGl0eShjaGFyYWN0ZXJzKSA6IGZhbHNlXG5cbiAgICAgICAgaWYgKG5hbWVkRW50aXR5KSB7XG4gICAgICAgICAgZW50aXR5Q2hhcmFjdGVycyA9IGNoYXJhY3RlcnNcbiAgICAgICAgICBlbnRpdHkgPSBuYW1lZEVudGl0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpZmYgPSAxICsgZW5kIC0gc3RhcnRcblxuICAgICAgaWYgKCF0ZXJtaW5hdGVkICYmICFub25UZXJtaW5hdGVkKSB7XG4gICAgICAgIC8vIEVtcHR5LlxuICAgICAgfSBlbHNlIGlmICghY2hhcmFjdGVycykge1xuICAgICAgICAvLyBBbiBlbXB0eSAocG9zc2libGUpIGVudGl0eSBpcyB2YWxpZCwgdW5sZXNzIGl04oCZcyBudW1lcmljICh0aHVzIGFuXG4gICAgICAgIC8vIGFtcGVyc2FuZCBmb2xsb3dlZCBieSBhbiBvY3RvdGhvcnApLlxuICAgICAgICBpZiAodHlwZSAhPT0gbmFtZSkge1xuICAgICAgICAgIHdhcm5pbmcobnVtZXJpY0VtcHR5LCBkaWZmKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IG5hbWUpIHtcbiAgICAgICAgLy8gQW4gYW1wZXJzYW5kIGZvbGxvd2VkIGJ5IGFueXRoaW5nIHVua25vd24sIGFuZCBub3QgdGVybWluYXRlZCwgaXNcbiAgICAgICAgLy8gaW52YWxpZC5cbiAgICAgICAgaWYgKHRlcm1pbmF0ZWQgJiYgIWVudGl0eSkge1xuICAgICAgICAgIHdhcm5pbmcobmFtZWRVbmtub3duLCAxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlcyBzb21ldGhpbmcgYWZ0ZXIgYW4gZW50aXR5IG5hbWUgd2hpY2ggaXMgbm90IGtub3duLCBjYXBcbiAgICAgICAgICAvLyB0aGUgcmVmZXJlbmNlLlxuICAgICAgICAgIGlmIChlbnRpdHlDaGFyYWN0ZXJzICE9PSBjaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgICBlbmQgPSBiZWdpbiArIGVudGl0eUNoYXJhY3RlcnMubGVuZ3RoXG4gICAgICAgICAgICBkaWZmID0gMSArIGVuZCAtIGJlZ2luXG4gICAgICAgICAgICB0ZXJtaW5hdGVkID0gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIG5vdCB0ZXJtaW5hdGVkLCB3YXJuLlxuICAgICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgICAgcmVhc29uID0gZW50aXR5Q2hhcmFjdGVycyA/IG5hbWVkTm90VGVybWluYXRlZCA6IG5hbWVkRW1wdHlcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICBmb2xsb3dpbmcgPSB2YWx1ZS5jaGFyQ29kZUF0KGVuZClcblxuICAgICAgICAgICAgICBpZiAoZm9sbG93aW5nID09PSBlcXVhbHNUbykge1xuICAgICAgICAgICAgICAgIHdhcm5pbmcocmVhc29uLCBkaWZmKVxuICAgICAgICAgICAgICAgIGVudGl0eSA9IG51bGxcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbHBoYW51bWVyaWNhbChmb2xsb3dpbmcpKSB7XG4gICAgICAgICAgICAgICAgZW50aXR5ID0gbnVsbFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm5pbmcocmVhc29uLCBkaWZmKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3YXJuaW5nKHJlYXNvbiwgZGlmZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWZlcmVuY2UgPSBlbnRpdHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgIC8vIEFsbCBub24tdGVybWluYXRlZCBudW1lcmljIGVudGl0aWVzIGFyZSBub3QgcmVuZGVyZWQsIGFuZCB0cmlnZ2VyIGFcbiAgICAgICAgICAvLyB3YXJuaW5nLlxuICAgICAgICAgIHdhcm5pbmcobnVtZXJpY05vdFRlcm1pbmF0ZWQsIGRpZmYpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIHRlcm1pbmF0ZWQgYW5kIG51bWJlciwgcGFyc2UgYXMgZWl0aGVyIGhleGFkZWNpbWFsIG9yIGRlY2ltYWwuXG4gICAgICAgIHJlZmVyZW5jZSA9IHBhcnNlSW50KGNoYXJhY3RlcnMsIGJhc2VzW3R5cGVdKVxuXG4gICAgICAgIC8vIFRyaWdnZXIgYSB3YXJuaW5nIHdoZW4gdGhlIHBhcnNlZCBudW1iZXIgaXMgcHJvaGliaXRlZCwgYW5kIHJlcGxhY2VcbiAgICAgICAgLy8gd2l0aCByZXBsYWNlbWVudCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChwcm9oaWJpdGVkKHJlZmVyZW5jZSkpIHtcbiAgICAgICAgICB3YXJuaW5nKG51bWVyaWNQcm9oaWJpdGVkLCBkaWZmKVxuICAgICAgICAgIHJlZmVyZW5jZSA9IGZyb21DaGFyQ29kZShyZXBsYWNlbWVudENoYXJhY3RlcilcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcmVuY2UgaW4gaW52YWxpZCkge1xuICAgICAgICAgIC8vIFRyaWdnZXIgYSB3YXJuaW5nIHdoZW4gdGhlIHBhcnNlZCBudW1iZXIgaXMgZGlzYWxsb3dlZCwgYW5kIHJlcGxhY2VcbiAgICAgICAgICAvLyBieSBhbiBhbHRlcm5hdGl2ZS5cbiAgICAgICAgICB3YXJuaW5nKG51bWVyaWNEaXNhbGxvd2VkLCBkaWZmKVxuICAgICAgICAgIHJlZmVyZW5jZSA9IGludmFsaWRbcmVmZXJlbmNlXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnNlIHRoZSBudW1iZXIuXG4gICAgICAgICAgb3V0cHV0ID0gJydcblxuICAgICAgICAgIC8vIFRyaWdnZXIgYSB3YXJuaW5nIHdoZW4gdGhlIHBhcnNlZCBudW1iZXIgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAgICAgIGlmIChkaXNhbGxvd2VkKHJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcobnVtZXJpY0Rpc2FsbG93ZWQsIGRpZmYpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RyaW5naWZ5IHRoZSBudW1iZXIuXG4gICAgICAgICAgaWYgKHJlZmVyZW5jZSA+IDB4ZmZmZikge1xuICAgICAgICAgICAgcmVmZXJlbmNlIC09IDB4MTAwMDBcbiAgICAgICAgICAgIG91dHB1dCArPSBmcm9tQ2hhckNvZGUoKHJlZmVyZW5jZSA+Pj4gKDEwICYgMHgzZmYpKSB8IDB4ZDgwMClcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IDB4ZGMwMCB8IChyZWZlcmVuY2UgJiAweDNmZilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWZlcmVuY2UgPSBvdXRwdXQgKyBmcm9tQ2hhckNvZGUocmVmZXJlbmNlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgLy8gRmlyc3QgZWF0IHRoZSBxdWV1ZWQgY2hhcmFjdGVycyBhcyBub3JtYWwgdGV4dCwgdGhlbiBlYXQgYW4gZW50aXR5LlxuICAgICAgaWYgKHJlZmVyZW5jZSkge1xuICAgICAgICBmbHVzaCgpXG5cbiAgICAgICAgcHJldiA9IG5vdygpXG4gICAgICAgIGluZGV4ID0gZW5kIC0gMVxuICAgICAgICBjb2x1bW4gKz0gZW5kIC0gc3RhcnQgKyAxXG4gICAgICAgIHJlc3VsdC5wdXNoKHJlZmVyZW5jZSlcbiAgICAgICAgbmV4dCA9IG5vdygpXG4gICAgICAgIG5leHQub2Zmc2V0KytcblxuICAgICAgICBpZiAoaGFuZGxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgaGFuZGxlUmVmZXJlbmNlLmNhbGwoXG4gICAgICAgICAgICByZWZlcmVuY2VDb250ZXh0LFxuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAge3N0YXJ0OiBwcmV2LCBlbmQ6IG5leHR9LFxuICAgICAgICAgICAgdmFsdWUuc2xpY2Uoc3RhcnQgLSAxLCBlbmQpXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJldiA9IG5leHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcmVmZXJlbmNlLCBxdWV1ZSB0aGUgY2hlY2tlZCBjaGFyYWN0ZXJzIChhc1xuICAgICAgICAvLyBub3JtYWwgY2hhcmFjdGVycyksIGFuZCBtb3ZlIHRoZSBwb2ludGVyIHRvIHRoZWlyIGVuZC5cbiAgICAgICAgLy8gVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIHdlIGNhbiBiZSBjZXJ0YWluIG5laXRoZXIgbmV3bGluZXMgbm9yXG4gICAgICAgIC8vIGFtcGVyc2FuZHMgYXJlIGluY2x1ZGVkLlxuICAgICAgICBjaGFyYWN0ZXJzID0gdmFsdWUuc2xpY2Uoc3RhcnQgLSAxLCBlbmQpXG4gICAgICAgIHF1ZXVlICs9IGNoYXJhY3RlcnNcbiAgICAgICAgY29sdW1uICs9IGNoYXJhY3RlcnMubGVuZ3RoXG4gICAgICAgIGluZGV4ID0gZW5kIC0gMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgYW55dGhpbmcgb3RoZXIgdGhhbiBhbiBhbXBlcnNhbmQsIGluY2x1ZGluZyBuZXdsaW5lcyBhbmQgRU9GLlxuICAgICAgaWYgKFxuICAgICAgICBjaGFyYWN0ZXIgPT09IDEwIC8vIExpbmUgZmVlZFxuICAgICAgKSB7XG4gICAgICAgIGxpbmUrK1xuICAgICAgICBsaW5lcysrXG4gICAgICAgIGNvbHVtbiA9IDBcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJhY3RlciA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgIHF1ZXVlICs9IGZyb21DaGFyQ29kZShjaGFyYWN0ZXIpXG4gICAgICAgIGNvbHVtbisrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbHVzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSByZWR1Y2VkIG5vZGVzLlxuICByZXR1cm4gcmVzdWx0LmpvaW4oJycpXG5cbiAgLy8gR2V0IGN1cnJlbnQgcG9zaXRpb24uXG4gIGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbGluZSxcbiAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgb2Zmc2V0OiBpbmRleCArIChwb3Mub2Zmc2V0IHx8IDApXG4gICAgfVxuICB9XG5cbiAgLy8g4oCcVGhyb3figJ0gYSBwYXJzZS1lcnJvcjogYSB3YXJuaW5nLlxuICBmdW5jdGlvbiBwYXJzZUVycm9yKGNvZGUsIG9mZnNldCkge1xuICAgIHZhciBwb3NpdGlvbiA9IG5vdygpXG5cbiAgICBwb3NpdGlvbi5jb2x1bW4gKz0gb2Zmc2V0XG4gICAgcG9zaXRpb24ub2Zmc2V0ICs9IG9mZnNldFxuXG4gICAgaGFuZGxlV2FybmluZy5jYWxsKHdhcm5pbmdDb250ZXh0LCBtZXNzYWdlc1tjb2RlXSwgcG9zaXRpb24sIGNvZGUpXG4gIH1cblxuICAvLyBGbHVzaCBgcXVldWVgIChub3JtYWwgdGV4dCkuXG4gIC8vIE1hY3JvIGludm9rZWQgYmVmb3JlIGVhY2ggZW50aXR5IGFuZCBhdCB0aGUgZW5kIG9mIGB2YWx1ZWAuXG4gIC8vIERvZXMgbm90aGluZyB3aGVuIGBxdWV1ZWAgaXMgZW1wdHkuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGlmIChxdWV1ZSkge1xuICAgICAgcmVzdWx0LnB1c2gocXVldWUpXG5cbiAgICAgIGlmIChoYW5kbGVUZXh0KSB7XG4gICAgICAgIGhhbmRsZVRleHQuY2FsbCh0ZXh0Q29udGV4dCwgcXVldWUsIHtzdGFydDogcHJldiwgZW5kOiBub3coKX0pXG4gICAgICB9XG5cbiAgICAgIHF1ZXVlID0gJydcbiAgICB9XG4gIH1cbn1cblxuLy8gQ2hlY2sgaWYgYGNoYXJhY3RlcmAgaXMgb3V0c2lkZSB0aGUgcGVybWlzc2libGUgdW5pY29kZSByYW5nZS5cbmZ1bmN0aW9uIHByb2hpYml0ZWQoY29kZSkge1xuICByZXR1cm4gKGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkZmZmKSB8fCBjb2RlID4gMHgxMGZmZmZcbn1cblxuLy8gQ2hlY2sgaWYgYGNoYXJhY3RlcmAgaXMgZGlzYWxsb3dlZC5cbmZ1bmN0aW9uIGRpc2FsbG93ZWQoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDB4MDAwMSAmJiBjb2RlIDw9IDB4MDAwOCkgfHxcbiAgICBjb2RlID09PSAweDAwMGIgfHxcbiAgICAoY29kZSA+PSAweDAwMGQgJiYgY29kZSA8PSAweDAwMWYpIHx8XG4gICAgKGNvZGUgPj0gMHgwMDdmICYmIGNvZGUgPD0gMHgwMDlmKSB8fFxuICAgIChjb2RlID49IDB4ZmRkMCAmJiBjb2RlIDw9IDB4ZmRlZikgfHxcbiAgICAoY29kZSAmIDB4ZmZmZikgPT09IDB4ZmZmZiB8fFxuICAgIChjb2RlICYgMHhmZmZmKSA9PT0gMHhmZmZlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJsZWdhY3kiLCJyZXF1aXJlIiwiaW52YWxpZCIsImRlY2ltYWwiLCJoZXhhZGVjaW1hbCIsImFscGhhbnVtZXJpY2FsIiwiZGVjb2RlRW50aXR5IiwibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlRW50aXRpZXMiLCJvd24iLCJoYXNPd25Qcm9wZXJ0eSIsImZyb21DaGFyQ29kZSIsIlN0cmluZyIsIm5vb3AiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImRlZmF1bHRzIiwid2FybmluZyIsInJlZmVyZW5jZSIsInRleHQiLCJ3YXJuaW5nQ29udGV4dCIsInJlZmVyZW5jZUNvbnRleHQiLCJ0ZXh0Q29udGV4dCIsInBvc2l0aW9uIiwiYWRkaXRpb25hbCIsImF0dHJpYnV0ZSIsIm5vblRlcm1pbmF0ZWQiLCJ0YWIiLCJsaW5lRmVlZCIsImZvcm1GZWVkIiwic3BhY2UiLCJhbXBlcnNhbmQiLCJzZW1pY29sb24iLCJsZXNzVGhhbiIsImVxdWFsc1RvIiwibnVtYmVyU2lnbiIsInVwcGVyY2FzZVgiLCJsb3dlcmNhc2VYIiwicmVwbGFjZW1lbnRDaGFyYWN0ZXIiLCJuYW1lIiwiaGV4YSIsImRlY2kiLCJiYXNlcyIsInRlc3RzIiwibmFtZWROb3RUZXJtaW5hdGVkIiwibnVtZXJpY05vdFRlcm1pbmF0ZWQiLCJuYW1lZEVtcHR5IiwibnVtZXJpY0VtcHR5IiwibmFtZWRVbmtub3duIiwibnVtZXJpY0Rpc2FsbG93ZWQiLCJudW1lcmljUHJvaGliaXRlZCIsIm1lc3NhZ2VzIiwidmFsdWUiLCJvcHRpb25zIiwic2V0dGluZ3MiLCJvcHRpb24iLCJrZXkiLCJ1bmRlZmluZWQiLCJpbmRlbnQiLCJzdGFydCIsInBhcnNlIiwiaGFuZGxlVGV4dCIsImhhbmRsZVJlZmVyZW5jZSIsImhhbmRsZVdhcm5pbmciLCJwb3MiLCJsZW5ndGgiLCJpbmRleCIsImxpbmVzIiwiY29sdW1uIiwibGluZSIsInF1ZXVlIiwicmVzdWx0IiwiZW50aXR5Q2hhcmFjdGVycyIsIm5hbWVkRW50aXR5IiwidGVybWluYXRlZCIsImNoYXJhY3RlcnMiLCJjaGFyYWN0ZXIiLCJmb2xsb3dpbmciLCJyZWFzb24iLCJvdXRwdXQiLCJlbnRpdHkiLCJiZWdpbiIsInR5cGUiLCJ0ZXN0IiwicHJldiIsIm5leHQiLCJkaWZmIiwiZW5kIiwiY2hhckNvZGVBdCIsIm5vdyIsInBhcnNlRXJyb3IiLCJjYWxsIiwicGFyc2VJbnQiLCJwcm9oaWJpdGVkIiwiZGlzYWxsb3dlZCIsImZsdXNoIiwicHVzaCIsIm9mZnNldCIsInNsaWNlIiwiam9pbiIsImNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/parse-entities/index.js\n");

/***/ })

};
;